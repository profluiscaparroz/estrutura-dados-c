# Vetores e Matrizes em C

Este diret√≥rio cont√©m exemplos completos e documenta√ß√£o sobre **vetores (arrays)** e **matrizes** em C, incluindo manipula√ß√£o de strings como vetores de caracteres.

## üìö Conte√∫do

### üìÅ Estrutura de Arquivos
- **`vetor/`** - Exemplos e exerc√≠cios com vetores unidimensionais
- **`matriz/`** - Exemplos e exerc√≠cios com matrizes (vetores bidimensionais)
- **`questoes-academicas.md`** - Quest√µes acad√™micas com respostas detalhadas
- **`README-exemplos-avancados.md`** - Guia de navega√ß√£o dos exemplos avan√ßados
- **`analise-performance.md`** - An√°lise de performance e otimiza√ß√µes

---

## üéØ Conceitos Fundamentais

### Vetores (Arrays)
Um **vetor** (ou array) √© uma estrutura de dados que armazena uma cole√ß√£o de elementos do mesmo tipo em posi√ß√µes consecutivas da mem√≥ria. Em C, vetores s√£o a base fundamental para muitas outras estruturas de dados e s√£o essenciais para compreender programa√ß√£o eficiente.

**Por que vetores s√£o importantes?**
- Permitem armazenar m√∫ltiplos valores relacionados em uma √∫nica vari√°vel
- Facilitam o processamento de grandes quantidades de dados
- S√£o a base para estruturas mais complexas como listas, pilhas e filas
- Oferecem acesso extremamente r√°pido aos elementos

#### Caracter√≠sticas dos Vetores:

- **Acesso direto:** O(1) - Tempo constante para acessar qualquer elemento
  - Voc√™ pode acessar diretamente o elemento na posi√ß√£o `i` usando `vetor[i]`
  - N√£o precisa percorrer outros elementos para chegar ao desejado
  - Exemplo: Se voc√™ quer o 100¬∫ elemento, acessa diretamente `vetor[99]` (lembrando que √≠ndices come√ßam em 0)

- **Mem√≥ria cont√≠gua:** Elementos armazenados sequencialmente na mem√≥ria RAM
  - Os elementos ocupam posi√ß√µes adjacentes na mem√≥ria
  - Se um elemento est√° no endere√ßo X, o pr√≥ximo est√° em X + tamanho_do_tipo
  - Isso permite c√°lculos r√°pidos de endere√ßos: `endere√ßo_do_elemento_i = endere√ßo_base + i * sizeof(tipo)`
  - Melhora o desempenho devido √† localidade de cache (cache locality)

- **√çndice baseado em zero:** Primeiro elemento no √≠ndice 0, √∫ltimo em (tamanho-1)
  - Esta conven√ß√£o vem da matem√°tica de ponteiros: `vetor[i]` √© equivalente a `*(vetor + i)`
  - Um vetor de 5 elementos tem √≠ndices 0, 1, 2, 3, 4 (nunca 5!)
  - Acessar `vetor[5]` em um vetor de tamanho 5 causa erro de acesso √† mem√≥ria (buffer overflow)

- **Tamanho fixo:** O tamanho deve ser definido e n√£o pode mudar facilmente
  - **Vetores est√°ticos:** Tamanho definido em tempo de compila√ß√£o
  - **Vetores din√¢micos:** Tamanho definido em tempo de execu√ß√£o com `malloc`, mas ainda fixo ap√≥s aloca√ß√£o
  - Para "aumentar" um vetor din√¢mico, √© necess√°rio alocar novo espa√ßo e copiar os dados (opera√ß√£o custosa)

#### Declara√ß√£o e Inicializa√ß√£o:

**1. Declara√ß√£o B√°sica (Sem Inicializa√ß√£o):**
```c
int numeros[5];  // Cria vetor com 5 posi√ß√µes
// ‚ö†Ô∏è CUIDADO: Valores iniciais s√£o indefinidos (lixo de mem√≥ria)
// √â boa pr√°tica inicializar antes de usar!
```

**2. Declara√ß√£o com Inicializa√ß√£o Completa:**
```c
int numeros[5] = {10, 20, 30, 40, 50};
// Cada posi√ß√£o recebe um valor espec√≠fico
// numeros[0] = 10, numeros[1] = 20, ..., numeros[4] = 50
```

**3. Declara√ß√£o com Inicializa√ß√£o Parcial:**
```c
int numeros[5] = {10, 20};
// numeros[0] = 10, numeros[1] = 20
// numeros[2] = 0, numeros[3] = 0, numeros[4] = 0
// Posi√ß√µes n√£o inicializadas recebem 0
```

**4. Inicializa√ß√£o com Zeros:**
```c
int numeros[5] = {0};  // Todos os elementos = 0
// Forma r√°pida e segura de zerar um vetor
```

**5. Tamanho Inferido pelo Compilador:**
```c
int numeros[] = {10, 20, 30, 40, 50};
// Compilador calcula tamanho = 5
// √ötil quando voc√™ n√£o quer contar os elementos manualmente
```

**6. Aloca√ß√£o Din√¢mica (Heap):**
```c
int *numeros = malloc(5 * sizeof(int));
// Aloca mem√≥ria em tempo de execu√ß√£o
// Permite tamanho vari√°vel (determinado durante execu√ß√£o)
// ‚ö†Ô∏è IMPORTANTE: Sempre verificar se malloc retornou NULL
// ‚ö†Ô∏è IMPORTANTE: Sempre fazer free(numeros) ao terminar de usar!

// Exemplo completo com verifica√ß√£o:
int tamanho = 5;
int *numeros = malloc(tamanho * sizeof(int));
if (numeros == NULL) {
    printf("Erro: N√£o foi poss√≠vel alocar mem√≥ria!\n");
    return 1;
}
// ... usar o vetor ...
free(numeros);  // Libera a mem√≥ria
```

**7. Aloca√ß√£o Din√¢mica Inicializada com Zeros:**
```c
int *numeros = calloc(5, sizeof(int));
// Similar ao malloc, mas inicializa tudo com 0
// calloc(n, size) = malloc(n * size) + inicializa√ß√£o com zeros
```

---

## üìä Opera√ß√µes B√°sicas com Vetores - Exemplos Detalhados

### 1. Acesso e Modifica√ß√£o de Elementos

**Acesso por √çndice:**
```c
int vetor[5] = {10, 20, 30, 40, 50};

// Leitura
int valor = vetor[2];  // valor = 30
printf("Elemento na posi√ß√£o 2: %d\n", vetor[2]);

// Modifica√ß√£o
vetor[2] = 99;  // Agora vetor = {10, 20, 99, 40, 50}

// Complexidade: O(1) - tempo constante
// Explica√ß√£o: O acesso √© direto via c√°lculo de endere√ßo
```

### 2. Percorrer um Vetor (Traversal)

**Percorrendo do in√≠cio ao fim:**
```c
int vetor[5] = {10, 20, 30, 40, 50};

// M√©todo 1: for tradicional
for (int i = 0; i < 5; i++) {
    printf("%d ", vetor[i]);
}
// Sa√≠da: 10 20 30 40 50

// M√©todo 2: while
int i = 0;
while (i < 5) {
    printf("%d ", vetor[i]);
    i++;
}

// Complexidade: O(n) onde n √© o tamanho do vetor
// Explica√ß√£o: Precisamos visitar cada elemento uma vez
```

### 3. Buscar um Elemento (Busca Linear)

```c
int buscar(int vetor[], int tamanho, int valor) {
    for (int i = 0; i < tamanho; i++) {
        if (vetor[i] == valor) {
            return i;  // Retorna a posi√ß√£o onde encontrou
        }
    }
    return -1;  // Retorna -1 se n√£o encontrou
}

// Exemplo de uso:
int numeros[5] = {10, 20, 30, 40, 50};
int posicao = buscar(numeros, 5, 30);
if (posicao != -1) {
    printf("Encontrado na posi√ß√£o %d\n", posicao);  // Sa√≠da: posi√ß√£o 2
}

// Complexidade: 
// - Melhor caso: O(1) - elemento est√° na primeira posi√ß√£o
// - Pior caso: O(n) - elemento est√° na √∫ltima posi√ß√£o ou n√£o existe
// - Caso m√©dio: O(n/2) = O(n) - em m√©dia, percorre metade do vetor
```

### 4. Inserir Elemento no Final

```c
int inserir_no_final(int *vetor, int *tamanho, int valor, int capacidade) {
    if (*tamanho >= capacidade) {
        printf("Erro: Vetor cheio!\n");
        return 0;  // Falha
    }
    
    vetor[*tamanho] = valor;  // Insere na pr√≥xima posi√ß√£o livre
    (*tamanho)++;              // Incrementa o tamanho
    return 1;  // Sucesso
}

// Exemplo:
int numeros[10] = {10, 20, 30};  // capacidade = 10, tamanho atual = 3
int tamanho = 3;
inserir_no_final(numeros, &tamanho, 40, 10);
// Agora: numeros = {10, 20, 30, 40, ...}, tamanho = 4

// Complexidade: O(1) - opera√ß√£o de tempo constante
// Explica√ß√£o: Apenas adiciona no final, sem mover elementos
```

### 5. Inserir Elemento em Posi√ß√£o Espec√≠fica

```c
int inserir_na_posicao(int vetor[], int *tamanho, int posicao, int valor, int capacidade) {
    // Valida√ß√µes
    if (*tamanho >= capacidade) {
        printf("Erro: Vetor cheio!\n");
        return 0;
    }
    if (posicao < 0 || posicao > *tamanho) {
        printf("Erro: Posi√ß√£o inv√°lida!\n");
        return 0;
    }
    
    // Desloca elementos para a direita
    // Come√ßa do final e vai at√© a posi√ß√£o desejada
    for (int i = *tamanho; i > posicao; i--) {
        vetor[i] = vetor[i-1];
    }
    
    vetor[posicao] = valor;  // Insere o novo valor
    (*tamanho)++;
    return 1;
}

// Exemplo visual:
// Vetor inicial: [10, 20, 30, 40, 50]
// Inserir 99 na posi√ß√£o 2:
//   Passo 1: [10, 20, 30, 40, 50, _] (aumenta espa√ßo)
//   Passo 2: [10, 20, 30, 40, 40, 50] (desloca 40)
//   Passo 3: [10, 20, 30, 30, 40, 50] (desloca 30)
//   Passo 4: [10, 20, 99, 30, 40, 50] (insere 99)

// Complexidade: O(n) onde n √© o n√∫mero de elementos ap√≥s a posi√ß√£o
// Explica√ß√£o: Precisa deslocar elementos para abrir espa√ßo
// - Melhor caso: O(1) - inserir no final
// - Pior caso: O(n) - inserir no in√≠cio (desloca todos)
```

### 6. Remover Elemento de Posi√ß√£o Espec√≠fica

```c
int remover_da_posicao(int vetor[], int *tamanho, int posicao) {
    if (posicao < 0 || posicao >= *tamanho) {
        printf("Erro: Posi√ß√£o inv√°lida!\n");
        return 0;
    }
    
    // Desloca elementos para a esquerda
    for (int i = posicao; i < *tamanho - 1; i++) {
        vetor[i] = vetor[i+1];
    }
    
    (*tamanho)--;
    return 1;
}

// Exemplo visual:
// Vetor inicial: [10, 20, 30, 40, 50]
// Remover da posi√ß√£o 2 (valor 30):
//   Passo 1: [10, 20, 40, 40, 50] (copia 40 para posi√ß√£o 2)
//   Passo 2: [10, 20, 40, 50, 50] (copia 50 para posi√ß√£o 3)
//   Resultado: [10, 20, 40, 50] (tamanho = 4)

// Complexidade: O(n)
// Explica√ß√£o: Similar √† inser√ß√£o, precisa deslocar elementos
// - Melhor caso: O(1) - remover do final
// - Pior caso: O(n) - remover do in√≠cio
```

### 7. Somar Todos os Elementos

```c
int somar_elementos(int vetor[], int tamanho) {
    int soma = 0;
    for (int i = 0; i < tamanho; i++) {
        soma += vetor[i];
    }
    return soma;
}

// Exemplo:
int numeros[5] = {10, 20, 30, 40, 50};
int resultado = somar_elementos(numeros, 5);
// resultado = 10 + 20 + 30 + 40 + 50 = 150

// Complexidade: O(n)
// Explica√ß√£o: Precisa visitar cada elemento uma vez
```

### 8. Encontrar Maior e Menor Elemento

```c
void encontrar_maior_menor(int vetor[], int tamanho, int *maior, int *menor) {
    if (tamanho == 0) return;
    
    *maior = vetor[0];  // Assume primeiro como maior
    *menor = vetor[0];  // Assume primeiro como menor
    
    for (int i = 1; i < tamanho; i++) {
        if (vetor[i] > *maior) {
            *maior = vetor[i];
        }
        if (vetor[i] < *menor) {
            *menor = vetor[i];
        }
    }
}

// Exemplo:
int numeros[5] = {30, 10, 50, 20, 40};
int maior, menor;
encontrar_maior_menor(numeros, 5, &maior, &menor);
// maior = 50, menor = 10

// Complexidade: O(n)
// Explica√ß√£o: Uma passada pelo vetor, comparando cada elemento
// N√∫mero de compara√ß√µes: 2(n-1) no pior caso
```

### 9. Reverter um Vetor

```c
void reverter_vetor(int vetor[], int tamanho) {
    int inicio = 0;
    int fim = tamanho - 1;
    
    while (inicio < fim) {
        // Troca elementos das extremidades
        int temp = vetor[inicio];
        vetor[inicio] = vetor[fim];
        vetor[fim] = temp;
        
        inicio++;
        fim--;
    }
}

// Exemplo visual:
// Inicial: [10, 20, 30, 40, 50]
// Passo 1: [50, 20, 30, 40, 10] (troca 10‚Üî50)
// Passo 2: [50, 40, 30, 20, 10] (troca 20‚Üî40)
// Final:   [50, 40, 30, 20, 10] (30 fica no meio)

// Complexidade: O(n/2) = O(n)
// Explica√ß√£o: Percorre metade do vetor fazendo trocas
// N√∫mero de trocas: n/2
```

### 10. Copiar um Vetor

```c
void copiar_vetor(int origem[], int destino[], int tamanho) {
    for (int i = 0; i < tamanho; i++) {
        destino[i] = origem[i];
    }
}

// Ou usando memcpy (mais r√°pido):
#include <string.h>
memcpy(destino, origem, tamanho * sizeof(int));

// Complexidade: O(n)
// Explica√ß√£o: Precisa copiar cada elemento individualmente
```

---

## üî§ Strings como Vetores de Caracteres

**Strings em C s√£o vetores de caracteres terminados com '\0'**. Esta √© uma das aplica√ß√µes mais importantes de vetores na programa√ß√£o C.

### Conceitos Fundamentais sobre Strings

#### 1. Representa√ß√£o de Strings
```c
// String literal
char nome[] = "Carlos";  // Array: ['C','a','r','l','o','s','\0']

// Declara√ß√£o com tamanho espec√≠fico
char nome[20] = "Carlos"; // 19 caracteres √∫teis + '\0'

// Ponteiro para string literal (somente leitura)
char *nome = "Carlos";

// Array de caracteres inicializado manualmente
char nome[] = {'C', 'a', 'r', 'l', 'o', 's', '\0'};
```

#### 2. Manipula√ß√£o B√°sica de Strings (Sem `string.h`)

**Calculando comprimento de string:**
```c
int comprimento_string(char *str) {
    int contador = 0;
    while (str[contador] != '\0') {
        contador++;
    }
    return contador;
}
```

**Copiando strings:**
```c
void copiar_string(char *destino, char *origem) {
    int i = 0;
    while (origem[i] != '\0') {
        destino[i] = origem[i];
        i++;
    }
    destino[i] = '\0'; // Adiciona terminador
}
```

**Concatenando strings:**
```c
void concatenar_string(char *destino, char *origem) {
    int i = 0, j = 0;
    
    // Encontra o final da string de destino
    while (destino[i] != '\0') {
        i++;
    }
    
    // Adiciona a string origem ao final
    while (origem[j] != '\0') {
        destino[i] = origem[j];
        i++;
        j++;
    }
    destino[i] = '\0'; // Adiciona terminador
}
```

#### 3. Vetores de Strings (Array de Strings)
```c
// Array de ponteiros para strings
char *nomes[3] = {"Ana", "Bruno", "Carlos"};

// Array bidimensional de caracteres
char nomes[3][20] = {"Ana", "Bruno", "Carlos"};

// Aloca√ß√£o din√¢mica de array de strings
char **nomes = malloc(3 * sizeof(char*));
nomes[0] = malloc(20 * sizeof(char));
strcpy(nomes[0], "Ana");
```

### Vantagens e Desvantagens

**Vantagens dos Vetores:**
- **Acesso r√°pido por √≠ndice:** O(1) - qualquer elemento pode ser acessado instantaneamente
- **Efici√™ncia de mem√≥ria:** Dados cont√≠guos sem overhead adicional (estruturas mais complexas t√™m ponteiros extras)
- **Cache-friendly:** Boa localidade espacial significa menos cache misses e melhor desempenho
- **Simplicidade:** F√°cil de entender e implementar, ideal para iniciantes
- **Previsibilidade:** Comportamento e performance s√£o previs√≠veis e determin√≠sticos

**Desvantagens dos Vetores:**
- **Tamanho fixo:** Vetores est√°ticos n√£o podem crescer; din√¢micos precisam de realoca√ß√£o custosa
- **Inser√ß√£o/remo√ß√£o custosa:** O(n) para opera√ß√µes no meio (exceto no final)
- **Possibilidade de overflow:** Acessar al√©m dos limites causa comportamento indefinido
- **Desperd√≠cio de mem√≥ria:** Se alocar muito espa√ßo preventivamente, pode desperdi√ßar RAM
- **N√£o h√° verifica√ß√£o autom√°tica:** C n√£o verifica limites automaticamente (diferente de outras linguagens)

### üìä Compara√ß√£o Visual: Vetor vs Outras Estruturas

```
VETOR (Array):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 10  ‚îÇ 20  ‚îÇ 30  ‚îÇ 40  ‚îÇ 50  ‚îÇ  ‚Üê Mem√≥ria cont√≠gua
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  [0]   [1]   [2]   [3]   [4]

Vantagem: Acesso direto O(1)
Desvantagem: Tamanho fixo

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

LISTA LIGADA:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îê
‚îÇ 10  ‚îÇ‚óè‚îÄ‚îº‚îÄ‚îÄ‚Üí‚îÇ 20  ‚îÇ‚óè‚îÄ‚îº‚îÄ‚îÄ‚Üí‚îÇ 30  ‚îÇ X‚îÇ  ‚Üê Mem√≥ria espalhada
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îò

Vantagem: Inser√ß√£o/remo√ß√£o O(1)
Desvantagem: Acesso sequencial O(n)

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

VETOR DIN√ÇMICO (ArrayList):
Capacidade: 8           Tamanho usado: 5
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 10  ‚îÇ 20  ‚îÇ 30  ‚îÇ 40  ‚îÇ 50  ‚îÇ     ‚îÇ     ‚îÇ     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îî‚îÄ espa√ßo reservado

Vantagem: Cresce automaticamente
Desvantagem: Realoca√ß√£o ocasional O(n)
```

**Vantagens das Strings como Vetores:**
- **Controle total:** Voc√™ decide como gerenciar a mem√≥ria e manipular os caracteres
- **Efici√™ncia m√°xima:** Sem overhead de estruturas complexas
- **Compatibilidade:** Funciona com todas as fun√ß√µes de sistema e APIs em C
- **Base educacional:** Entender strings como vetores √© fundamental para C

**Desvantagens das Strings como Vetores:**
- **Gerenciamento manual:** Voc√™ √© respons√°vel por alocar e liberar mem√≥ria
- **Vulnerabilidade:** Buffer overflow √© um dos bugs mais comuns e perigosos
- **Terminador '\0':** Esquecer o terminador causa bugs dif√≠ceis de debugar
- **Sem funcionalidades avan√ßadas:** Sem m√©todos prontos como em linguagens modernas (Python, Java)

### üéì Quando Usar Vetores?

**‚úÖ Use vetores quando:**
- Voc√™ sabe o tamanho dos dados (ou um limite m√°ximo razo√°vel)
- Precisa de acesso r√°pido por √≠ndice
- Os dados s√£o processados sequencialmente
- A performance √© cr√≠tica (algoritmos, processamento cient√≠fico)
- Est√° implementando estruturas de dados b√°sicas (pilhas, filas)

**‚ùå Evite vetores quando:**
- O tamanho dos dados √© muito vari√°vel e imprevis√≠vel
- H√° muitas inser√ß√µes/remo√ß√µes no meio dos dados
- A ordem dos elementos muda frequentemente
- Precisa de busca eficiente sem ordem (use hash table)
- Precisa de relacionamentos complexos (use grafos)

**Vantagens das Strings como Vetores:**
- Controle total sobre a mem√≥ria
- Efici√™ncia m√°xima
- Compatibilidade com fun√ß√µes de sistema
- Base para entender outras estruturas

**Desvantagens das Strings como Vetores:**
- Gerenciamento manual da mem√≥ria
- Vulnerabilidade a buffer overflow
- Necessidade de controlar o terminador '\0'
- Aus√™ncia de funcionalidades avan√ßadas

---

## üé≤ Matrizes (Arrays Bidimensionais)

### Conceitos Fundamentais

Uma **matriz** √© um vetor de vetores, organizando dados em **linhas e colunas**, formando uma estrutura bidimensional. Matrizes s√£o fundamentais para representar dados tabulares, imagens, grafos e muito mais.

**Por que matrizes s√£o importantes?**
- Representam dados em forma de tabela (planilhas, grades)
- Essenciais em √°lgebra linear e computa√ß√£o cient√≠fica
- Usadas em processamento de imagens (cada pixel √© um elemento)
- Representam grafos atrav√©s de matrizes de adjac√™ncia
- Fundamentais em machine learning e deep learning

**Visualiza√ß√£o:**
```
Matriz 3x4 (3 linhas, 4 colunas):

        coluna 0  coluna 1  coluna 2  coluna 3
linha 0    [1]       [2]       [3]       [4]
linha 1    [5]       [6]       [7]       [8]
linha 2    [9]       [10]      [11]      [12]

Acesso: matriz[linha][coluna]
Exemplo: matriz[1][2] = 7
```

### Representa√ß√£o na Mem√≥ria

**Matrizes est√°ticas em C s√£o armazenadas em row-major order (ordem por linhas):**
```
Matriz 3x4:
[1]  [2]  [3]  [4]
[5]  [6]  [7]  [8]
[9]  [10] [11] [12]

Na mem√≥ria (sequencial):
[1][2][3][4][5][6][7][8][9][10][11][12]
‚îî‚îÄ linha 0 ‚îÄ‚îò‚îî‚îÄ linha 1 ‚îÄ‚îò‚îî‚îÄ linha 2 ‚îÄ‚îò

Endere√ßo do elemento [i][j]:
endere√ßo_base + (i * num_colunas + j) * sizeof(tipo)
```

**Esta organiza√ß√£o tem implica√ß√µes importantes:**
- Acessar elementos da mesma linha √© mais r√°pido (cache-friendly)
- Percorrer por colunas pode ser mais lento (cache misses)
- Processamento por linhas √© geralmente mais eficiente

#### Declara√ß√£o de Matrizes:

**1. Declara√ß√£o B√°sica:**
```c
int matriz[3][4];  // 3 linhas, 4 colunas (12 elementos total)
// ‚ö†Ô∏è Valores iniciais s√£o indefinidos
```

**2. Inicializa√ß√£o Completa:**
```c
int matriz[2][3] = {
    {1, 2, 3},    // linha 0
    {4, 5, 6}     // linha 1
};
// matriz[0][0]=1, matriz[0][1]=2, ..., matriz[1][2]=6
```

**3. Inicializa√ß√£o Alternativa (forma linear):**
```c
int matriz[2][3] = {1, 2, 3, 4, 5, 6};
// Compilador distribui automaticamente:
// {1,2,3} -> linha 0
// {4,5,6} -> linha 1
```

**4. Inicializa√ß√£o Parcial:**
```c
int matriz[2][3] = {
    {1, 2},       // linha 0: [1, 2, 0]
    {4}           // linha 1: [4, 0, 0]
};
// Elementos n√£o especificados = 0
```

**5. Inicializa√ß√£o com Zeros:**
```c
int matriz[3][4] = {0};  // Todos os elementos = 0
// Forma r√°pida e segura de zerar uma matriz
```

**6. Tamanho Inferido (primeira dimens√£o):**
```c
int matriz[][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
// Compilador infere: matriz[2][3]
// ‚ö†Ô∏è N√∫mero de colunas DEVE ser especificado!
```

**7. Aloca√ß√£o Din√¢mica - M√©todo 1 (array de ponteiros):**
```c
int linhas = 3, colunas = 4;
int **matriz = malloc(linhas * sizeof(int*));

for (int i = 0; i < linhas; i++) {
    matriz[i] = malloc(colunas * sizeof(int));
}

// Usar: matriz[i][j]

// Liberar mem√≥ria:
for (int i = 0; i < linhas; i++) {
    free(matriz[i]);
}
free(matriz);
```

**8. Aloca√ß√£o Din√¢mica - M√©todo 2 (bloco cont√≠guo):**
```c
int linhas = 3, colunas = 4;
int *matriz = malloc(linhas * colunas * sizeof(int));

// Acessar elemento [i][j]:
// matriz[i * colunas + j]

// Ou criar uma macro:
#define MAT(i,j) matriz[(i)*colunas + (j)]
// Usar: MAT(1,2) = 10;

// Liberar: free(matriz);
```

#### Strings em Matrizes:
```c
// Matriz de caracteres (uma string grande)
char texto[5][20]; // 5 strings de at√© 19 caracteres cada

// Preenchendo a matriz
strcpy(texto[0], "Primeira linha");
strcpy(texto[1], "Segunda linha");
```

### üéì Visualiza√ß√£o Did√°tica: Como a Matriz Funciona na Mem√≥ria

**Exemplo: Matriz 3√ó4 de inteiros (assumindo int = 4 bytes)**

```
Declara√ß√£o: int matriz[3][4];

Visualiza√ß√£o conceitual (2D):
        Col 0   Col 1   Col 2   Col 3
Row 0   [0]     [1]     [2]     [3]
Row 1   [4]     [5]     [6]     [7]
Row 2   [8]     [9]     [10]    [11]

Visualiza√ß√£o na mem√≥ria (1D linear):
Endere√ßo  |  Offset  |  Elemento
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
0x1000    |    0     |  matriz[0][0]
0x1004    |    4     |  matriz[0][1]
0x1008    |    8     |  matriz[0][2]
0x100C    |   12     |  matriz[0][3]  ‚Üê fim da linha 0
0x1010    |   16     |  matriz[1][0]  ‚Üê in√≠cio da linha 1
0x1014    |   20     |  matriz[1][1]
0x1018    |   24     |  matriz[1][2]
0x101C    |   28     |  matriz[1][3]
0x1020    |   32     |  matriz[2][0]
0x1024    |   36     |  matriz[2][1]
0x1028    |   40     |  matriz[2][2]
0x102C    |   44     |  matriz[2][3]

F√≥rmula de endere√ßo para matriz[i][j]:
endere√ßo = base + (i √ó num_colunas + j) √ó sizeof(tipo)
endere√ßo = 0x1000 + (i √ó 4 + j) √ó 4

Exemplo matriz[1][2]:
endere√ßo = 0x1000 + (1 √ó 4 + 2) √ó 4
         = 0x1000 + (4 + 2) √ó 4
         = 0x1000 + 6 √ó 4
         = 0x1000 + 24
         = 0x1018  ‚úì
```

### üîÑ Padr√µes de Acesso e Performance

**Por que acessar por linhas √© mais r√°pido?**

```
ACESSO POR LINHAS (cache-friendly):
for (i = 0; i < 3; i++)
    for (j = 0; j < 4; j++)
        soma += matriz[i][j];

Ordem de acesso: [0][0], [0][1], [0][2], [0][3], [1][0], [1][1]...
                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ sequencial na mem√≥ria ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Cache behavior:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Cache line carrega v√°rios         ‚îÇ
‚îÇ elementos adjacentes de uma vez   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚Üì          ‚Üì          ‚Üì
  [0][0]‚Äî‚Üí[0][1]‚Äî‚Üí[0][2]‚Äî‚Üí[0][3]  ‚Üê Uma cache line

Resultado: Poucos cache misses! ‚úÖ R√ÅPIDO

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

ACESSO POR COLUNAS (cache-unfriendly):
for (j = 0; j < 4; j++)
    for (i = 0; i < 3; i++)
        soma += matriz[i][j];

Ordem de acesso: [0][0], [1][0], [2][0], [0][1], [1][1]...
                  ‚îî‚îÄ‚î¨‚îÄ‚îò   ‚îî‚îÄ‚î¨‚îÄ‚îò   ‚îî‚îÄ‚î¨‚îÄ‚îò
                 +16 bytes cada salto!

Cache behavior:
Cache line: [0][0][0][1][0][2][0][3]
Acessa:     [0][0] ‚úì
            [1][0] ‚úó (outro cache line)
            [2][0] ‚úó (outro cache line)

Resultado: Muitos cache misses! ‚ùå LENTO (2-5√ó mais lento)
```

### üß† Conceitos Importantes sobre Matrizes

**1. Matriz vs Array de Ponteiros:**
```c
// M√©todo 1: Matriz est√°tica (recomendado quando poss√≠vel)
int matriz[3][4];
// + Mem√≥ria cont√≠gua (mais r√°pida)
// + Menos fragmenta√ß√£o
// + Sintaxe simples
// - Tamanho fixo em tempo de compila√ß√£o

// M√©todo 2: Array de ponteiros (flex√≠vel)
int **matriz = malloc(3 * sizeof(int*));
for (int i = 0; i < 3; i++)
    matriz[i] = malloc(4 * sizeof(int));
// + Tamanho din√¢mico
// + Pode ter linhas de tamanhos diferentes
// - Mem√≥ria fragmentada (mais lenta)
// - Mais complexo de gerenciar
// - Overhead de ponteiros

// M√©todo 3: Bloco cont√≠guo (melhor dos dois mundos)
int *matriz = malloc(3 * 4 * sizeof(int));
// Acesso: matriz[i * colunas + j]
// + Mem√≥ria cont√≠gua (r√°pida como M√©todo 1)
// + Tamanho din√¢mico (flex√≠vel como M√©todo 2)
// + Apenas uma chamada malloc (eficiente)
// - Sintaxe menos intuitiva
```

**2. Tipos Especiais de Matrizes:**
```
MATRIZ QUADRADA (n √ó n):
[1  2  3]
[4  5  6]  ‚Üê 3 linhas, 3 colunas
[7  8  9]

MATRIZ IDENTIDADE:
[1  0  0]
[0  1  0]  ‚Üê Diagonal = 1, resto = 0
[0  0  1]

MATRIZ DIAGONAL:
[5  0  0]
[0  3  0]  ‚Üê Apenas diagonal ‚â† 0
[0  0  8]

MATRIZ SIM√âTRICA:
[1  2  3]
[2  5  6]  ‚Üê mat[i][j] = mat[j][i]
[3  6  9]

MATRIZ TRIANGULAR SUPERIOR:
[1  2  3]
[0  5  6]  ‚Üê Abaixo da diagonal = 0
[0  0  9]

MATRIZ ESPARSA (sparse):
[0  0  5  0]
[0  0  0  0]  ‚Üê Maioria dos elementos = 0
[2  0  0  0]  ‚Üê Usar matriz completa desperdi√ßa mem√≥ria
[0  0  0  8]
```

### üí° Aplica√ß√µes Pr√°ticas de Matrizes

**1. Processamento de Imagens:**
```
Imagem 800√ó600 pixels = Matriz [600][800] de cores
Cada pixel = {R, G, B} = 3 bytes
Total: 800 √ó 600 √ó 3 = 1.440.000 bytes ‚âà 1.4 MB

Opera√ß√µes:
- Filtro blur: m√©dia dos vizinhos
- Detec√ß√£o de bordas: gradientes
- Rota√ß√£o: transforma√ß√£o matricial
```

**2. Jogos (Grade/Tabuleiro):**
```
Sudoku: matriz [9][9]
Xadrez: matriz [8][8]
Campo Minado: matriz [m][n]
Tetris: matriz [20][10]
```

**3. Grafos (Matriz de Adjac√™ncia):**
```
Grafo com 4 n√≥s:
  0‚îÄ‚îÄ1
  ‚îÇ  ‚îÇ
  2‚îÄ‚îÄ3

Matriz de adjac√™ncia [4][4]:
    0  1  2  3
0  [0  1  1  0]  ‚Üê N√≥ 0 conecta a 1 e 2
1  [1  0  0  1]  ‚Üê N√≥ 1 conecta a 0 e 3
2  [1  0  0  1]
3  [0  1  1  0]

mat[i][j] = 1 se h√° aresta entre i e j
```

**4. Sistemas Lineares (√Ålgebra Linear):**
```
Sistema:
2x + 3y = 8
4x - y = 2

Matriz aumentada [2][3]:
[2   3  | 8]
[4  -1  | 2]

Resolver usando elimina√ß√£o de Gauss
```

---

## üìê Opera√ß√µes com Matrizes - Exemplos Detalhados

### 1. Acesso e Modifica√ß√£o de Elementos

```c
int matriz[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};

// Leitura
int valor = matriz[1][2];  // linha 1, coluna 2 = 7

// Modifica√ß√£o
matriz[1][2] = 99;  // Agora matriz[1][2] = 99

// Complexidade: O(1) - acesso direto
```

### 2. Percorrer uma Matriz

**Percorrer por linhas (mais eficiente):**
```c
int matriz[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};

// Percorre linha por linha
for (int i = 0; i < 3; i++) {           // Para cada linha
    for (int j = 0; j < 4; j++) {       // Para cada coluna
        printf("%d ", matriz[i][j]);
    }
    printf("\n");
}
// Sa√≠da:
// 1 2 3 4
// 5 6 7 8
// 9 10 11 12

// Complexidade: O(m √ó n) onde m=linhas, n=colunas
// Explica√ß√£o: Visita cada um dos m√ón elementos uma vez
```

**Percorrer por colunas:**
```c
// Percorre coluna por coluna
for (int j = 0; j < 4; j++) {           // Para cada coluna
    for (int i = 0; i < 3; i++) {       // Para cada linha
        printf("%d ", matriz[i][j]);
    }
    printf("\n");
}
// Sa√≠da:
// 1 5 9
// 2 6 10
// 3 7 11
// 4 8 12

// ‚ö†Ô∏è Menos eficiente que percorrer por linhas devido ao cache
```

### 3. Soma de Matrizes

```c
void somar_matrizes(int A[][4], int B[][4], int resultado[][4], int linhas, int colunas) {
    for (int i = 0; i < linhas; i++) {
        for (int j = 0; j < colunas; j++) {
            resultado[i][j] = A[i][j] + B[i][j];
        }
    }
}

// Exemplo:
int A[2][3] = {{1, 2, 3}, {4, 5, 6}};
int B[2][3] = {{7, 8, 9}, {10, 11, 12}};
int C[2][3];

somar_matrizes(A, B, C, 2, 3);
// C = {{8, 10, 12}, {14, 16, 18}}

// Complexidade: O(m √ó n)
// Explica√ß√£o: Percorre cada elemento uma vez
// N√∫mero de opera√ß√µes: m √ó n somas
```

### 4. Multiplica√ß√£o de Matrizes

```c
void multiplicar_matrizes(int A[][10], int B[][10], int C[][10], 
                          int m, int n, int p) {
    // A √© m√ón, B √© n√óp, C ser√° m√óp
    
    // Inicializa C com zeros
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < p; j++) {
            C[i][j] = 0;
        }
    }
    
    // Calcula multiplica√ß√£o
    for (int i = 0; i < m; i++) {           // Para cada linha de A
        for (int j = 0; j < p; j++) {       // Para cada coluna de B
            for (int k = 0; k < n; k++) {   // Produto escalar
                C[i][j] += A[i][k] * B[k][j];
            }
        }
    }
}

// Exemplo visual:
// A (2√ó3):        B (3√ó2):        C (2√ó2):
// [1  2  3]       [7  8]          [?  ?]
// [4  5  6]       [9  10]         [?  ?]
//                 [11 12]
//
// C[0][0] = 1√ó7 + 2√ó9 + 3√ó11 = 7 + 18 + 33 = 58
// C[0][1] = 1√ó8 + 2√ó10 + 3√ó12 = 8 + 20 + 36 = 64
// C[1][0] = 4√ó7 + 5√ó9 + 6√ó11 = 28 + 45 + 66 = 139
// C[1][1] = 4√ó8 + 5√ó10 + 6√ó12 = 32 + 50 + 72 = 154
//
// Resultado C:
// [58   64]
// [139  154]

// Complexidade: O(m √ó n √ó p)
// Explica√ß√£o: Tr√™s loops aninhados
// N√∫mero de multiplica√ß√µes: m √ó n √ó p
// N√∫mero de somas: m √ó p √ó (n-1)
// ‚ö†Ô∏è Esta √© uma opera√ß√£o custosa para matrizes grandes!
```

### 5. Transposi√ß√£o de Matriz

```c
void transpor(int matriz[][4], int transposta[][3], int linhas, int colunas) {
    for (int i = 0; i < linhas; i++) {
        for (int j = 0; j < colunas; j++) {
            transposta[j][i] = matriz[i][j];
        }
    }
}

// Exemplo visual:
// Original (2√ó3):     Transposta (3√ó2):
// [1  2  3]           [1  4]
// [4  5  6]           [2  5]
//                     [3  6]
//
// Linha vira coluna, coluna vira linha

// Complexidade: O(m √ó n)
// Explica√ß√£o: Visita cada elemento uma vez
```

**Transposi√ß√£o in-place (matriz quadrada):**
```c
void transpor_quadrada(int matriz[][4], int n) {
    for (int i = 0; i < n; i++) {
        for (int j = i+1; j < n; j++) {  // j come√ßa em i+1
            // Troca matriz[i][j] com matriz[j][i]
            int temp = matriz[i][j];
            matriz[i][j] = matriz[j][i];
            matriz[j][i] = temp;
        }
    }
}

// ‚ö†Ô∏è S√≥ funciona para matrizes quadradas (n√ón)
// Complexidade: O(n¬≤/2) = O(n¬≤)
// Vantagem: N√£o precisa de matriz auxiliar
```

### 6. Buscar Elemento em Matriz

```c
int buscar_elemento(int matriz[][4], int linhas, int colunas, int valor, 
                    int *linha_result, int *coluna_result) {
    for (int i = 0; i < linhas; i++) {
        for (int j = 0; j < colunas; j++) {
            if (matriz[i][j] == valor) {
                *linha_result = i;
                *coluna_result = j;
                return 1;  // Encontrou
            }
        }
    }
    return 0;  // N√£o encontrou
}

// Exemplo:
int matriz[3][4] = {{1,2,3,4}, {5,6,7,8}, {9,10,11,12}};
int linha, coluna;

if (buscar_elemento(matriz, 3, 4, 7, &linha, &coluna)) {
    printf("Encontrado em [%d][%d]\n", linha, coluna);  // [1][2]
}

// Complexidade: O(m √ó n)
// - Melhor caso: O(1) - elemento na posi√ß√£o [0][0]
// - Pior caso: O(m√ón) - elemento na √∫ltima posi√ß√£o ou n√£o existe
```

**Busca em matriz ordenada (algoritmo otimizado):**
```c
// Para matriz onde cada linha e coluna est√° ordenada
int buscar_matriz_ordenada(int matriz[][4], int linhas, int colunas, int valor) {
    int i = 0;
    int j = colunas - 1;  // Come√ßa no canto superior direito
    
    while (i < linhas && j >= 0) {
        if (matriz[i][j] == valor) {
            return 1;  // Encontrou
        }
        else if (matriz[i][j] > valor) {
            j--;  // Move para esquerda
        }
        else {
            i++;  // Move para baixo
        }
    }
    return 0;  // N√£o encontrou
}

// Complexidade: O(m + n) - muito melhor que O(m√ón)!
// Funciona apenas para matrizes ordenadas
```

### 7. Somar Elementos da Diagonal Principal

```c
int somar_diagonal(int matriz[][4], int n) {
    int soma = 0;
    for (int i = 0; i < n; i++) {
        soma += matriz[i][i];  // Elementos onde linha == coluna
    }
    return soma;
}

// Exemplo:
// [1  2  3]
// [4  5  6]  -> diagonal: 1, 5, 9 -> soma = 15
// [7  8  9]

// Complexidade: O(n)
// Explica√ß√£o: Visita apenas n elementos (n√£o n¬≤)
```

### 8. Rota√ß√£o de Matriz 90 Graus

```c
void rotacionar_90(int matriz[][4], int n) {
    // Passo 1: Transpor a matriz
    for (int i = 0; i < n; i++) {
        for (int j = i+1; j < n; j++) {
            int temp = matriz[i][j];
            matriz[i][j] = matriz[j][i];
            matriz[j][i] = temp;
        }
    }
    
    // Passo 2: Inverter cada linha
    for (int i = 0; i < n; i++) {
        int esq = 0, dir = n-1;
        while (esq < dir) {
            int temp = matriz[i][esq];
            matriz[i][esq] = matriz[i][dir];
            matriz[i][dir] = temp;
            esq++;
            dir--;
        }
    }
}

// Exemplo visual:
// Original:          Ap√≥s transpor:     Ap√≥s inverter linhas:
// [1  2  3]          [1  4  7]          [7  4  1]
// [4  5  6]    ->    [2  5  8]    ->    [8  5  2]
// [7  8  9]          [3  6  9]          [9  6  3]
//
// Rota√ß√£o 90¬∞ no sentido hor√°rio

// Complexidade: O(n¬≤)
// Explica√ß√£o: Transpor = O(n¬≤/2), Inverter = O(n¬≤/2), Total = O(n¬≤)
```

### 9. Verificar Matriz Sim√©trica

```c
int eh_simetrica(int matriz[][4], int n) {
    for (int i = 0; i < n; i++) {
        for (int j = i+1; j < n; j++) {
            if (matriz[i][j] != matriz[j][i]) {
                return 0;  // N√£o √© sim√©trica
            }
        }
    }
    return 1;  // √â sim√©trica
}

// Matriz sim√©trica: matriz[i][j] == matriz[j][i] para todo i,j
// Exemplo:
// [1  2  3]
// [2  5  6]  -> Sim√©trica (espelhada na diagonal)
// [3  6  9]

// Complexidade: O(n¬≤/2) = O(n¬≤)
// Apenas verifica metade dos elementos (acima da diagonal)
```

### 10. Preencher Matriz em Espiral

```c
void preencher_espiral(int matriz[][10], int n) {
    int valor = 1;
    int cima = 0, baixo = n-1, esq = 0, dir = n-1;
    
    while (cima <= baixo && esq <= dir) {
        // Preenche linha superior (esquerda -> direita)
        for (int j = esq; j <= dir; j++) {
            matriz[cima][j] = valor++;
        }
        cima++;
        
        // Preenche coluna direita (cima -> baixo)
        for (int i = cima; i <= baixo; i++) {
            matriz[i][dir] = valor++;
        }
        dir--;
        
        // Preenche linha inferior (direita -> esquerda)
        if (cima <= baixo) {
            for (int j = dir; j >= esq; j--) {
                matriz[baixo][j] = valor++;
            }
            baixo--;
        }
        
        // Preenche coluna esquerda (baixo -> cima)
        if (esq <= dir) {
            for (int i = baixo; i >= cima; i--) {
                matriz[i][esq] = valor++;
            }
            esq++;
        }
    }
}

// Exemplo para matriz 4√ó4:
// [1   2   3   4]
// [12  13  14  5]
// [11  16  15  6]
// [10  9   8   7]

// Complexidade: O(n¬≤)
// Explica√ß√£o: Preenche todos os n¬≤ elementos em ordem espiral
```

---

## ‚ö° An√°lise de Complexidade Computacional - Detalhada

### O que √© Complexidade Computacional?

A **complexidade computacional** mede a efici√™ncia de um algoritmo em termos de:
- **Tempo:** Quantas opera√ß√µes s√£o necess√°rias?
- **Espa√ßo:** Quanta mem√≥ria √© necess√°ria?

Usamos a **nota√ß√£o Big O** para descrever o comportamento assint√≥tico (quando n cresce muito).

### Nota√ß√µes Comuns de Complexidade

**Do mais r√°pido para o mais lento:**

1. **O(1) - Constante:** Sempre executa o mesmo n√∫mero de opera√ß√µes
   - Exemplo: Acessar `vetor[5]`
   - N√£o importa se o vetor tem 10 ou 1 milh√£o de elementos

2. **O(log n) - Logar√≠tmica:** Cresce muito lentamente
   - Exemplo: Busca bin√°ria em vetor ordenado
   - Dobrar n adiciona apenas uma opera√ß√£o

3. **O(n) - Linear:** Cresce proporcionalmente ao tamanho
   - Exemplo: Percorrer um vetor
   - Dobrar n dobra o n√∫mero de opera√ß√µes

4. **O(n log n) - Linear√≠tmica:** Quase linear
   - Exemplo: Algoritmos eficientes de ordena√ß√£o (Merge Sort, Quick Sort)
   - Melhor que O(n¬≤) para grandes valores de n

5. **O(n¬≤) - Quadr√°tica:** Cresce rapidamente
   - Exemplo: Dois loops aninhados
   - Dobrar n quadruplica o n√∫mero de opera√ß√µes

6. **O(n¬≥) - C√∫bica:** Muito lento para grandes n
   - Exemplo: Tr√™s loops aninhados
   - Multiplica√ß√£o ing√™nua de matrizes

7. **O(2‚Åø) - Exponencial:** Extremamente lento
   - Exemplo: Problemas de for√ßa bruta
   - Impratic√°vel para n > 30

**Compara√ß√£o visual (para n = 100):**
```
O(1)        = 1 opera√ß√£o
O(log n)    ‚âà 7 opera√ß√µes
O(n)        = 100 opera√ß√µes
O(n log n)  ‚âà 700 opera√ß√µes
O(n¬≤)       = 10.000 opera√ß√µes
O(n¬≥)       = 1.000.000 opera√ß√µes
O(2‚Åø)       ‚âà 1.267.650.600.228.229.401.496.703.205.376 opera√ß√µes (impratic√°vel!)
```

### Complexidade de Opera√ß√µes em Vetores e Matrizes

#### **Vetores (Array 1D)**

| Opera√ß√£o | Complexidade | Explica√ß√£o Detalhada |
|----------|--------------|----------------------|
| **Acesso** | O(1) | C√°lculo direto: `endere√ßo = base + i √ó sizeof(tipo)`. Uma opera√ß√£o aritm√©tica. |
| **Modifica√ß√£o** | O(1) | Acessa e modifica diretamente. Uma ou duas opera√ß√µes. |
| **Busca (n√£o ordenado)** | O(n) | No pior caso, verifica todos os n elementos. M√©dia: n/2 compara√ß√µes. |
| **Busca (ordenado)** | O(log n) | Busca bin√°ria: divide pela metade a cada passo. log‚ÇÇ(n) compara√ß√µes. |
| **Inser√ß√£o no final** | O(1)* | Se h√° espa√ßo, apenas adiciona. *Amortizado se usar realoca√ß√£o din√¢mica. |
| **Inser√ß√£o no in√≠cio** | O(n) | Precisa deslocar todos os n elementos uma posi√ß√£o √† direita. |
| **Inser√ß√£o no meio** | O(n) | Em m√©dia, desloca n/2 elementos. Pior caso: desloca n elementos. |
| **Remo√ß√£o do final** | O(1) | Apenas decrementa o tamanho. Nenhum deslocamento. |
| **Remo√ß√£o do in√≠cio** | O(n) | Desloca todos os n-1 elementos √† esquerda. |
| **Remo√ß√£o do meio** | O(n) | Em m√©dia, desloca n/2 elementos. |
| **Percorrer** | O(n) | Visita cada um dos n elementos exatamente uma vez. |
| **Reverter** | O(n) | n/2 trocas, cada troca √© O(1). Total: O(n). |
| **Copiar** | O(n) | Copia cada um dos n elementos. |
| **Somar elementos** | O(n) | Uma adi√ß√£o para cada elemento. n adi√ß√µes. |
| **Encontrar maior/menor** | O(n) | Uma ou duas compara√ß√µes por elemento. n-1 itera√ß√µes. |
| **Ordena√ß√£o** | O(n¬≤) ou O(n log n) | Bubble/Insertion: O(n¬≤). Merge/Quick: O(n log n). |

**An√°lise Detalhada - Inser√ß√£o no Meio:**
```c
// Inserir valor na posi√ß√£o k em vetor de tamanho n
void inserir(int v[], int n, int k, int valor) {
    for (int i = n; i > k; i--) {  // Loop executa (n-k) vezes
        v[i] = v[i-1];              // Cada itera√ß√£o: 1 atribui√ß√£o
    }
    v[k] = valor;                   // 1 atribui√ß√£o final
}

// An√°lise de casos:
// Melhor caso (k = n): 0 deslocamentos -> O(1)
// Pior caso (k = 0): n deslocamentos -> O(n)
// Caso m√©dio (k = n/2): n/2 deslocamentos -> O(n)
```

#### **Matrizes (Array 2D)**

| Opera√ß√£o | Complexidade | Explica√ß√£o Detalhada |
|----------|--------------|----------------------|
| **Acesso** | O(1) | `endere√ßo = base + (i √ó cols + j) √ó sizeof`. Opera√ß√£o aritm√©tica constante. |
| **Busca Linear** | O(m √ó n) | Verifica todos os m√ón elementos no pior caso. |
| **Busca (ordenada)** | O(m + n) | Algoritmo especial partindo do canto. Muito melhor que O(m√ón)! |
| **Percorrer** | O(m √ó n) | Visita cada um dos m√ón elementos uma vez. |
| **Soma de matrizes** | O(m √ó n) | Uma adi√ß√£o para cada um dos m√ón elementos. |
| **Multiplica√ß√£o** | O(m √ó n √ó p) | Tr√™s loops aninhados. Para cada elemento de C (m√ón), faz p multiplica√ß√µes. |
| **Transposi√ß√£o** | O(m √ó n) | Copia cada elemento uma vez para nova posi√ß√£o. |
| **Transposi√ß√£o in-place** | O(n¬≤) | Apenas matrizes quadradas. n¬≤/2 trocas. |
| **Inser√ß√£o de linha** | O(m √ó n) | Precisa deslocar todas as linhas abaixo. |
| **Remo√ß√£o de linha** | O(m √ó n) | Desloca todas as linhas abaixo para cima. |
| **Diagonal** | O(n) | Apenas n elementos na diagonal de matriz n√ón. |
| **Rota√ß√£o 90¬∞** | O(n¬≤) | Transpor (O(n¬≤)) + inverter linhas (O(n¬≤)) = O(n¬≤). |

**An√°lise Detalhada - Multiplica√ß√£o de Matrizes:**
```c
// C = A √ó B, onde A √© m√ón, B √© n√óp, C √© m√óp
void multiplicar(int A[][N], int B[][P], int C[][P], int m, int n, int p) {
    for (int i = 0; i < m; i++) {          // Loop m vezes
        for (int j = 0; j < p; j++) {      // Loop p vezes
            C[i][j] = 0;                    // 1 atribui√ß√£o
            for (int k = 0; k < n; k++) {  // Loop n vezes
                C[i][j] += A[i][k] * B[k][j];  // 1 mult + 1 soma
            }
        }
    }
}

// Contagem de opera√ß√µes:
// - N√∫mero de elementos em C: m √ó p
// - Para cada elemento: n multiplica√ß√µes + n somas
// - Total de multiplica√ß√µes: m √ó n √ó p
// - Total de somas: m √ó n √ó p
// - Complexidade total: O(m √ó n √ó p)
//
// Exemplo: Multiplicar duas matrizes 1000√ó1000
// Opera√ß√µes: 1000 √ó 1000 √ó 1000 = 1.000.000.000 (1 bilh√£o!)
// A 1 GHz: aproximadamente 1 segundo
```

### Complexidade de Espa√ßo

**Vetores:**
- Vetor est√°tico de n elementos: **O(n)** bytes (n √ó sizeof(tipo))
- Vetor din√¢mico: **O(n)** + overhead do malloc (alguns bytes extras)

**Matrizes:**
- Matriz m√ón est√°tica: **O(m √ó n)** bytes
- Matriz m√ón din√¢mica (ponteiros): **O(m √ó n) + O(m)** para array de ponteiros
- Matriz cont√≠gua: **O(m √ó n)** (mais eficiente)

**Exemplo:**
```c
int vetor[1000];              // 1000 √ó 4 = 4.000 bytes = 4 KB
int matriz[100][100];         // 10.000 √ó 4 = 40.000 bytes = 40 KB
int matriz_3d[50][50][50];    // 125.000 √ó 4 = 500.000 bytes = 500 KB
```

### Impacto da Complexidade no Mundo Real

**Exemplo 1: Busca Linear vs Busca Bin√°ria**
```
Vetor de 1 milh√£o de elementos:
- Busca linear: at√© 1.000.000 compara√ß√µes (pior caso)
- Busca bin√°ria: at√© 20 compara√ß√µes (log‚ÇÇ(1.000.000) ‚âà 20)
- Diferen√ßa: 50.000 vezes mais r√°pido!
```

**Exemplo 2: Multiplica√ß√£o de Matrizes**
```
Matrizes 1000√ó1000:
- Algoritmo ing√™nuo O(n¬≥): 1.000.000.000 opera√ß√µes
- Algoritmo de Strassen O(n^2.8): ‚âà 159.000.000 opera√ß√µes
- Diferen√ßa: 6,3 vezes mais r√°pido!

Matrizes 2000√ó2000:
- Algoritmo ing√™nuo: 8.000.000.000 opera√ß√µes (8√ó maior)
- Tempo: aproximadamente 8 segundos (a 1 GHz)
```

**Exemplo 3: Import√¢ncia do Cache**
```c
// M√©todo 1: Percorrer por linhas (cache-friendly)
for (int i = 0; i < 1000; i++)
    for (int j = 0; j < 1000; j++)
        soma += matriz[i][j];
// Tempo: ~1 ms

// M√©todo 2: Percorrer por colunas (cache miss)
for (int j = 0; j < 1000; j++)
    for (int i = 0; i < 1000; i++)
        soma += matriz[i][j];
// Tempo: ~3-5 ms
// Mesma complexidade O(n¬≤), mas 3-5√ó mais lento na pr√°tica!
```

### Dicas para Otimiza√ß√£o

1. **Evite opera√ß√µes O(n) dentro de loops:**
   ```c
   // ‚ùå Ruim: O(n¬≤)
   for (int i = 0; i < n; i++)
       for (int j = 0; j < strlen(str); j++)  // strlen √© O(n)!
   
   // ‚úÖ Bom: O(n)
   int len = strlen(str);  // Calcular uma vez
   for (int i = 0; i < n; i++)
       for (int j = 0; j < len; j++)
   ```

2. **Percorra matrizes por linhas, n√£o por colunas**

3. **Use busca bin√°ria quando poss√≠vel** (se o vetor est√° ordenado)

4. **Algoritmos O(n log n) s√£o aceit√°veis para n at√© 10‚Å∂**

5. **Algoritmos O(n¬≤) s√£o aceit√°veis para n at√© 10‚Å¥**

6. **Algoritmos O(n¬≥) s√£o aceit√°veis para n at√© 500**

---

## ‚ö° Opera√ß√µes Comuns e Complexidade - Tabela Resumida

| Opera√ß√£o | Vetor | Matriz | Complexidade |
|----------|--------|--------|--------------|
| Acesso | `arr[i]` | `mat[i][j]` | O(1) |
| Busca Linear | percorrer | percorrer linhas/colunas | O(n) / O(m√ón) |
| Inser√ß√£o no final | adicionar | adicionar linha/coluna | O(1) / O(n) |
| Inser√ß√£o no meio | deslocar elementos | reestruturar | O(n) / O(m√ón) |
| Remo√ß√£o | deslocar elementos | reestruturar | O(n) / O(m√ón) |

---

## üîß Exemplos Pr√°ticos Detalhados

### 1. Sistema de Gerenciamento de Notas

**Problema:** Criar um sistema para armazenar e processar notas de alunos.

**C√≥digo Completo com Explica√ß√µes:**
```c
#include <stdio.h>
#include <string.h>

#define MAX_ALUNOS 50
#define MAX_NOME 50
#define NUM_PROVAS 3

// Estrutura para representar um aluno
typedef struct {
    char nome[MAX_NOME];
    float notas[NUM_PROVAS];
    float media;
} Aluno;

// Fun√ß√£o para calcular a m√©dia das notas
// Complexidade: O(NUM_PROVAS) = O(1) (constante pequena)
float calcular_media(float notas[], int quantidade) {
    float soma = 0;
    for (int i = 0; i < quantidade; i++) {
        soma += notas[i];
    }
    return soma / quantidade;
}

// Fun√ß√£o para encontrar o aluno com maior m√©dia
// Complexidade: O(n) onde n √© o n√∫mero de alunos
int encontrar_melhor_aluno(Aluno alunos[], int quantidade) {
    int indice_melhor = 0;
    float maior_media = alunos[0].media;
    
    for (int i = 1; i < quantidade; i++) {
        if (alunos[i].media > maior_media) {
            maior_media = alunos[i].media;
            indice_melhor = i;
        }
    }
    
    return indice_melhor;
}

// Fun√ß√£o para exibir relat√≥rio completo
// Complexidade: O(n) onde n √© o n√∫mero de alunos
void exibir_relatorio(Aluno alunos[], int quantidade) {
    printf("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë              RELAT√ìRIO DE NOTAS DOS ALUNOS                 ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n");
    
    printf("%-20s  Prova1  Prova2  Prova3  M√©dia   Status\n", "Nome");
    printf("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n");
    
    for (int i = 0; i < quantidade; i++) {
        printf("%-20s  %6.2f  %6.2f  %6.2f  %6.2f  %s\n",
               alunos[i].nome,
               alunos[i].notas[0],
               alunos[i].notas[1],
               alunos[i].notas[2],
               alunos[i].media,
               alunos[i].media >= 7.0 ? "‚úì Aprovado" : "‚úó Reprovado");
    }
    
    // Estat√≠sticas
    int melhor = encontrar_melhor_aluno(alunos, quantidade);
    printf("\nüèÜ Melhor aluno: %s (M√©dia: %.2f)\n", 
           alunos[melhor].nome, alunos[melhor].media);
}

int main() {
    Aluno turma[MAX_ALUNOS];
    int num_alunos = 3;
    
    // Dados de exemplo
    strcpy(turma[0].nome, "Ana Silva");
    turma[0].notas[0] = 8.5; turma[0].notas[1] = 9.0; turma[0].notas[2] = 8.0;
    
    strcpy(turma[1].nome, "Bruno Costa");
    turma[1].notas[0] = 7.0; turma[1].notas[1] = 6.5; turma[1].notas[2] = 7.5;
    
    strcpy(turma[2].nome, "Carla Santos");
    turma[2].notas[0] = 9.5; turma[2].notas[1] = 10.0; turma[2].notas[2] = 9.0;
    
    // Calcula m√©dias
    for (int i = 0; i < num_alunos; i++) {
        turma[i].media = calcular_media(turma[i].notas, NUM_PROVAS);
    }
    
    // Exibe relat√≥rio
    exibir_relatorio(turma, num_alunos);
    
    return 0;
}
```

**An√°lise de Complexidade Total:**
- Calcular m√©dias: O(n √ó k) onde n=alunos, k=provas
- Encontrar melhor: O(n)
- Exibir relat√≥rio: O(n)
- **Total: O(n)** (assumindo k constante)

---

### 2. Processador de Texto Avan√ßado

**Problema:** Analisar um texto e extrair estat√≠sticas.

**C√≥digo Completo:**
```c
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#define MAX_TEXTO 1000
#define MAX_PALAVRAS 200

// Estrutura para an√°lise de texto
typedef struct {
    int num_caracteres;
    int num_palavras;
    int num_linhas;
    int num_vogais;
    int num_consoantes;
    int num_digitos;
} EstatisticasTexto;

// Verifica se um caractere √© vogal
// Complexidade: O(1)
int eh_vogal(char c) {
    c = tolower(c);
    return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');
}

// Analisa o texto e retorna estat√≠sticas
// Complexidade: O(n) onde n √© o tamanho do texto
EstatisticasTexto analisar_texto(char *texto) {
    EstatisticasTexto stats = {0, 0, 0, 0, 0, 0};
    int em_palavra = 0;
    
    for (int i = 0; texto[i] != '\0'; i++) {
        stats.num_caracteres++;
        
        if (texto[i] == '\n') {
            stats.num_linhas++;
        }
        
        if (isalpha(texto[i])) {
            if (eh_vogal(texto[i])) {
                stats.num_vogais++;
            } else {
                stats.num_consoantes++;
            }
        }
        
        if (isdigit(texto[i])) {
            stats.num_digitos++;
        }
        
        // Contar palavras
        if (isalpha(texto[i])) {
            if (!em_palavra) {
                stats.num_palavras++;
                em_palavra = 1;
            }
        } else {
            em_palavra = 0;
        }
    }
    
    // √öltima linha (se texto n√£o termina com \n)
    if (stats.num_caracteres > 0 && texto[stats.num_caracteres-1] != '\n') {
        stats.num_linhas++;
    }
    
    return stats;
}

// Converte texto para mai√∫sculas
// Complexidade: O(n)
void para_maiuscula(char *texto) {
    for (int i = 0; texto[i] != '\0'; i++) {
        texto[i] = toupper(texto[i]);
    }
}

// Inverte uma string
// Complexidade: O(n/2) = O(n)
void inverter_string(char *str) {
    int inicio = 0;
    int fim = strlen(str) - 1;
    
    while (inicio < fim) {
        char temp = str[inicio];
        str[inicio] = str[fim];
        str[fim] = temp;
        inicio++;
        fim--;
    }
}

// Conta ocorr√™ncias de uma palavra no texto
// Complexidade: O(n √ó m) onde n=tamanho do texto, m=tamanho da palavra
int contar_ocorrencias(char *texto, char *palavra) {
    int contador = 0;
    int tam_palavra = strlen(palavra);
    int tam_texto = strlen(texto);
    
    for (int i = 0; i <= tam_texto - tam_palavra; i++) {
        int j;
        for (j = 0; j < tam_palavra; j++) {
            if (tolower(texto[i+j]) != tolower(palavra[j])) {
                break;
            }
        }
        if (j == tam_palavra) {
            // Verifica se √© palavra completa (n√£o parte de outra)
            int antes_ok = (i == 0 || !isalpha(texto[i-1]));
            int depois_ok = (i+tam_palavra >= tam_texto || !isalpha(texto[i+tam_palavra]));
            if (antes_ok && depois_ok) {
                contador++;
            }
        }
    }
    
    return contador;
}

void exibir_estatisticas(EstatisticasTexto stats) {
    printf("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë    ESTAT√çSTICAS DO TEXTO          ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n");
    printf("  üìù Caracteres:    %d\n", stats.num_caracteres);
    printf("  üìñ Palavras:      %d\n", stats.num_palavras);
    printf("  üìÑ Linhas:        %d\n", stats.num_linhas);
    printf("  üî§ Vogais:        %d\n", stats.num_vogais);
    printf("  üî° Consoantes:    %d\n", stats.num_consoantes);
    printf("  üî¢ D√≠gitos:       %d\n", stats.num_digitos);
    
    if (stats.num_palavras > 0) {
        float media_chars = (float)stats.num_caracteres / stats.num_palavras;
        printf("  üìä M√©dia chars/palavra: %.2f\n", media_chars);
    }
}

int main() {
    char texto[] = "Estruturas de dados sao fundamentais em Ciencia da Computacao.\n"
                   "Vetores e matrizes sao estruturas basicas mas muito importantes.\n"
                   "Dominando estes conceitos, voce estara preparado para estruturas mais complexas.";
    
    printf("Texto original:\n%s\n", texto);
    
    // Analisa o texto
    EstatisticasTexto stats = analisar_texto(texto);
    exibir_estatisticas(stats);
    
    // Conta ocorr√™ncias de "estruturas"
    char palavra[] = "estruturas";
    int ocorrencias = contar_ocorrencias(texto, palavra);
    printf("\n  üîç Palavra '%s' aparece %d vez(es)\n", palavra, ocorrencias);
    
    // Demonstra invers√£o
    char exemplo[] = "Programacao";
    printf("\n  Original: %s\n", exemplo);
    inverter_string(exemplo);
    printf("  Invertida: %s\n", exemplo);
    
    return 0;
}
```

**Sa√≠da Esperada:**
```
Texto original:
Estruturas de dados sao fundamentais em Ciencia da Computacao.
Vetores e matrizes sao estruturas basicas mas muito importantes.
Dominando estes conceitos, voce estara preparado para estruturas mais complexas.

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë    ESTAT√çSTICAS DO TEXTO          ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

  üìù Caracteres:    193
  üìñ Palavras:      26
  üìÑ Linhas:        3
  üî§ Vogais:        73
  üî° Consoantes:    87
  üî¢ D√≠gitos:       0
  üìä M√©dia chars/palavra: 7.42

  üîç Palavra 'estruturas' aparece 3 vez(es)

  Original: Programacao
  Invertida: oacamargorP
```

---

### 3. Manipulador de Matrizes - Opera√ß√µes Matem√°ticas

**Problema:** Implementar opera√ß√µes comuns com matrizes.

**C√≥digo Completo:**
```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX 10

// Aloca matriz dinamicamente
// Complexidade: O(linhas)
int** alocar_matriz(int linhas, int colunas) {
    int **mat = malloc(linhas * sizeof(int*));
    for (int i = 0; i < linhas; i++) {
        mat[i] = malloc(colunas * sizeof(int));
    }
    return mat;
}

// Libera matriz
// Complexidade: O(linhas)
void liberar_matriz(int **mat, int linhas) {
    for (int i = 0; i < linhas; i++) {
        free(mat[i]);
    }
    free(mat);
}

// Preenche matriz com valores aleat√≥rios
// Complexidade: O(m √ó n)
void preencher_aleatoria(int **mat, int linhas, int colunas, int max_valor) {
    for (int i = 0; i < linhas; i++) {
        for (int j = 0; j < colunas; j++) {
            mat[i][j] = rand() % max_valor;
        }
    }
}

// Imprime matriz
// Complexidade: O(m √ó n)
void imprimir_matriz(int **mat, int linhas, int colunas, char *titulo) {
    printf("\n%s (%dx%d):\n", titulo, linhas, colunas);
    for (int i = 0; i < linhas; i++) {
        for (int j = 0; j < colunas; j++) {
            printf("%4d ", mat[i][j]);
        }
        printf("\n");
    }
}

// Soma duas matrizes
// Complexidade: O(m √ó n)
int** somar_matrizes(int **A, int **B, int linhas, int colunas) {
    int **C = alocar_matriz(linhas, colunas);
    
    for (int i = 0; i < linhas; i++) {
        for (int j = 0; j < colunas; j++) {
            C[i][j] = A[i][j] + B[i][j];
        }
    }
    
    return C;
}

// Multiplica duas matrizes
// Complexidade: O(m √ó n √ó p)
int** multiplicar_matrizes(int **A, int **B, int m, int n, int p) {
    int **C = alocar_matriz(m, p);
    
    // Inicializa com zero
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < p; j++) {
            C[i][j] = 0;
        }
    }
    
    // Multiplica√ß√£o
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < p; j++) {
            for (int k = 0; k < n; k++) {
                C[i][j] += A[i][k] * B[k][j];
            }
        }
    }
    
    return C;
}

// Transp√µe matriz
// Complexidade: O(m √ó n)
int** transpor_matriz(int **mat, int linhas, int colunas) {
    int **transp = alocar_matriz(colunas, linhas);
    
    for (int i = 0; i < linhas; i++) {
        for (int j = 0; j < colunas; j++) {
            transp[j][i] = mat[i][j];
        }
    }
    
    return transp;
}

// Verifica se matriz √© identidade
// Complexidade: O(n¬≤)
int eh_identidade(int **mat, int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (i == j) {
                if (mat[i][j] != 1) return 0;
            } else {
                if (mat[i][j] != 0) return 0;
            }
        }
    }
    return 1;
}

// Cria matriz identidade
// Complexidade: O(n¬≤)
int** criar_identidade(int n) {
    int **mat = alocar_matriz(n, n);
    
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            mat[i][j] = (i == j) ? 1 : 0;
        }
    }
    
    return mat;
}

int main() {
    srand(time(NULL));
    
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë    CALCULADORA DE OPERA√á√ïES COM MATRIZES      ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    
    // Exemplo 1: Soma de matrizes
    printf("\n[1] SOMA DE MATRIZES\n");
    int **A = alocar_matriz(2, 3);
    int **B = alocar_matriz(2, 3);
    
    preencher_aleatoria(A, 2, 3, 10);
    preencher_aleatoria(B, 2, 3, 10);
    
    imprimir_matriz(A, 2, 3, "Matriz A");
    imprimir_matriz(B, 2, 3, "Matriz B");
    
    int **C = somar_matrizes(A, B, 2, 3);
    imprimir_matriz(C, 2, 3, "C = A + B");
    
    // Exemplo 2: Multiplica√ß√£o de matrizes
    printf("\n[2] MULTIPLICA√á√ÉO DE MATRIZES\n");
    int **D = alocar_matriz(2, 3);
    int **E = alocar_matriz(3, 2);
    
    preencher_aleatoria(D, 2, 3, 5);
    preencher_aleatoria(E, 3, 2, 5);
    
    imprimir_matriz(D, 2, 3, "Matriz D");
    imprimir_matriz(E, 3, 2, "Matriz E");
    
    int **F = multiplicar_matrizes(D, E, 2, 3, 2);
    imprimir_matriz(F, 2, 2, "F = D √ó E");
    
    // Exemplo 3: Transposi√ß√£o
    printf("\n[3] TRANSPOSI√á√ÉO\n");
    int **G = alocar_matriz(2, 4);
    preencher_aleatoria(G, 2, 4, 20);
    
    imprimir_matriz(G, 2, 4, "Matriz G");
    
    int **GT = transpor_matriz(G, 2, 4);
    imprimir_matriz(GT, 4, 2, "G^T (Transposta)");
    
    // Exemplo 4: Matriz identidade
    printf("\n[4] MATRIZ IDENTIDADE\n");
    int **I = criar_identidade(4);
    imprimir_matriz(I, 4, 4, "Matriz Identidade 4x4");
    printf("√â identidade? %s\n", eh_identidade(I, 4) ? "Sim" : "N√£o");
    
    // Limpeza
    liberar_matriz(A, 2);
    liberar_matriz(B, 2);
    liberar_matriz(C, 2);
    liberar_matriz(D, 2);
    liberar_matriz(E, 3);
    liberar_matriz(F, 2);
    liberar_matriz(G, 2);
    liberar_matriz(GT, 4);
    liberar_matriz(I, 4);
    
    return 0;
}
```

**Conceitos Demonstrados:**
- ‚úÖ Aloca√ß√£o din√¢mica de matrizes
- ‚úÖ Opera√ß√µes matem√°ticas (soma, multiplica√ß√£o, transposi√ß√£o)
- ‚úÖ Verifica√ß√£o de propriedades (matriz identidade)
- ‚úÖ Gerenciamento de mem√≥ria (aloca√ß√£o e libera√ß√£o)
- ‚úÖ Formata√ß√£o de sa√≠da profissional

---

### 4. Jogo da Velha (Tic-Tac-Toe) - Matriz 3√ó3

**Problema:** Implementar o cl√°ssico jogo da velha usando matriz.

**C√≥digo Completo:**
```c
#include <stdio.h>

#define TAM 3

// Inicializa o tabuleiro
// Complexidade: O(1) - sempre 3√ó3 = 9 opera√ß√µes
void inicializar_tabuleiro(char tabuleiro[TAM][TAM]) {
    for (int i = 0; i < TAM; i++) {
        for (int j = 0; j < TAM; j++) {
            tabuleiro[i][j] = ' ';
        }
    }
}

// Exibe o tabuleiro
// Complexidade: O(1) - sempre 3√ó3
void exibir_tabuleiro(char tabuleiro[TAM][TAM]) {
    printf("\n");
    printf("     0   1   2\n");
    printf("   ‚ïî‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïó\n");
    for (int i = 0; i < TAM; i++) {
        printf(" %d ‚ïë %c ‚ïë %c ‚ïë %c ‚ïë\n", i,
               tabuleiro[i][0], tabuleiro[i][1], tabuleiro[i][2]);
        if (i < TAM - 1) {
            printf("   ‚ï†‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ï£\n");
        }
    }
    printf("   ‚ïö‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïù\n");
}

// Verifica se posi√ß√£o √© v√°lida
// Complexidade: O(1)
int posicao_valida(char tabuleiro[TAM][TAM], int linha, int coluna) {
    if (linha < 0 || linha >= TAM || coluna < 0 || coluna >= TAM) {
        return 0;  // Fora dos limites
    }
    return tabuleiro[linha][coluna] == ' ';  // Verifica se est√° vazia
}

// Faz jogada
// Complexidade: O(1)
int fazer_jogada(char tabuleiro[TAM][TAM], int linha, int coluna, char jogador) {
    if (!posicao_valida(tabuleiro, linha, coluna)) {
        return 0;  // Jogada inv√°lida
    }
    
    tabuleiro[linha][coluna] = jogador;
    return 1;  // Jogada v√°lida
}

// Verifica vit√≥ria
// Complexidade: O(1) - sempre verifica 8 condi√ß√µes
char verificar_vitoria(char tabuleiro[TAM][TAM]) {
    // Verifica linhas
    for (int i = 0; i < TAM; i++) {
        if (tabuleiro[i][0] != ' ' &&
            tabuleiro[i][0] == tabuleiro[i][1] &&
            tabuleiro[i][1] == tabuleiro[i][2]) {
            return tabuleiro[i][0];
        }
    }
    
    // Verifica colunas
    for (int j = 0; j < TAM; j++) {
        if (tabuleiro[0][j] != ' ' &&
            tabuleiro[0][j] == tabuleiro[1][j] &&
            tabuleiro[1][j] == tabuleiro[2][j]) {
            return tabuleiro[0][j];
        }
    }
    
    // Verifica diagonal principal
    if (tabuleiro[0][0] != ' ' &&
        tabuleiro[0][0] == tabuleiro[1][1] &&
        tabuleiro[1][1] == tabuleiro[2][2]) {
        return tabuleiro[0][0];
    }
    
    // Verifica diagonal secund√°ria
    if (tabuleiro[0][2] != ' ' &&
        tabuleiro[0][2] == tabuleiro[1][1] &&
        tabuleiro[1][1] == tabuleiro[2][0]) {
        return tabuleiro[0][2];
    }
    
    return ' ';  // Nenhum vencedor
}

// Verifica empate
// Complexidade: O(1) - sempre 9 posi√ß√µes
int verificar_empate(char tabuleiro[TAM][TAM]) {
    for (int i = 0; i < TAM; i++) {
        for (int j = 0; j < TAM; j++) {
            if (tabuleiro[i][j] == ' ') {
                return 0;  // Ainda h√° posi√ß√µes vazias
            }
        }
    }
    return 1;  // Empate (tabuleiro cheio e nenhum vencedor)
}

int main() {
    char tabuleiro[TAM][TAM];
    char jogador_atual = 'X';
    int linha, coluna;
    int jogadas = 0;
    
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë      JOGO DA VELHA (3√ó3)          ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    
    inicializar_tabuleiro(tabuleiro);
    
    // Loop do jogo
    while (1) {
        exibir_tabuleiro(tabuleiro);
        
        printf("\nJogador %c, fa√ßa sua jogada!\n", jogador_atual);
        printf("Linha (0-2): ");
        scanf("%d", &linha);
        printf("Coluna (0-2): ");
        scanf("%d", &coluna);
        
        if (fazer_jogada(tabuleiro, linha, coluna, jogador_atual)) {
            jogadas++;
            
            // Verifica vit√≥ria
            char vencedor = verificar_vitoria(tabuleiro);
            if (vencedor != ' ') {
                exibir_tabuleiro(tabuleiro);
                printf("\nüéâ Jogador %c venceu! Parab√©ns! üéâ\n", vencedor);
                break;
            }
            
            // Verifica empate
            if (verificar_empate(tabuleiro)) {
                exibir_tabuleiro(tabuleiro);
                printf("\nü§ù Empate! Bom jogo! ü§ù\n");
                break;
            }
            
            // Alterna jogador
            jogador_atual = (jogador_atual == 'X') ? 'O' : 'X';
        } else {
            printf("\n‚ùå Jogada inv√°lida! Tente novamente.\n");
        }
    }
    
    printf("\nTotal de jogadas: %d\n", jogadas);
    
    return 0;
}
```

**Conceitos Demonstrados:**
- ‚úÖ Uso pr√°tico de matriz 2D
- ‚úÖ Valida√ß√£o de entrada
- ‚úÖ Verifica√ß√£o de padr√µes (linhas, colunas, diagonais)
- ‚úÖ Interface visual com caracteres especiais
- ‚úÖ L√≥gica de jogo completa

**Complexidade Total:** O(1) para todas as opera√ß√µes (tamanho fixo 3√ó3)

---

---

## üìñ Material de Estudo

### Para Iniciantes:
1. Execute `vetor/exemplo/exemploSimples.c`
2. Estude `matriz/exemploMatrizSimples.c`
3. Leia as primeiras quest√µes em `questoes-academicas.md`

### Para Intermedi√°rios:
1. Analise `vetor/exemplo/exemploAvancado.c`
2. Implemente as fun√ß√µes de string manualmente
3. Estude aloca√ß√£o din√¢mica de matrizes

### Para Avan√ßados:
1. Execute `aplicacoes-praticas.c`
2. Analise performance em `analise-performance.md`
3. Implemente algoritmos de processamento de texto

---

## üöÄ Como Compilar e Executar

```bash
# Compilar exemplo b√°sico
make exemploSimples

# Compilar todos os exemplos
make all

# Executar testes
make test

# Limpar execut√°veis
make clean
```

---

## ‚ö†Ô∏è Cuidados Importantes e Boas Pr√°ticas

### 1. Buffer Overflow - O Erro Mais Perigoso

**O que √© Buffer Overflow?**
Escrever al√©m dos limites de um vetor, corrompendo mem√≥ria adjacente.

```c
// ‚ùå PERIGOSO - Buffer Overflow!
char buffer[10];  // 10 bytes: 0-9
strcpy(buffer, "String muito longa que n√£o cabe");  // 32 bytes!

Mem√≥ria antes:
[buffer: 10 bytes][outras vari√°veis][dados importantes]

Mem√≥ria depois do overflow:
[buffer cheio][CORROMPIDO!][CORROMPIDO!][CORROMPIDO!]
                ‚Üë
         Dados importantes destru√≠dos!
         Pode causar:
         - Crash do programa
         - Comportamento imprevis√≠vel
         - Vulnerabilidade de seguran√ßa
```

**‚úÖ Solu√ß√µes Seguras:**
```c
// M√©todo 1: Usar strncpy (com cuidado!)
char buffer[10];
strncpy(buffer, "String longa", sizeof(buffer) - 1);
buffer[sizeof(buffer) - 1] = '\0';  // ‚ö†Ô∏è IMPORTANTE: garantir terminador

// M√©todo 2: Usar snprintf (recomendado)
char buffer[10];
snprintf(buffer, sizeof(buffer), "%s", "String longa");
// Automaticamente adiciona '\0' e n√£o ultrapassa o tamanho

// M√©todo 3: Verificar tamanho antes
char *origem = "String qualquer";
size_t tam_necessario = strlen(origem) + 1;  // +1 para '\0'
if (tam_necessario <= sizeof(buffer)) {
    strcpy(buffer, origem);  // Seguro
} else {
    printf("Erro: String muito grande!\n");
}

// M√©todo 4: Aloca√ß√£o din√¢mica (melhor para strings de tamanho vari√°vel)
char *origem = "String de qualquer tamanho";
char *buffer = malloc(strlen(origem) + 1);
if (buffer != NULL) {
    strcpy(buffer, origem);  // Agora √© seguro
    // ... usar buffer ...
    free(buffer);  // N√£o esquecer!
}
```

### 2. Acesso Fora dos Limites (Out of Bounds)

```c
int vetor[5] = {10, 20, 30, 40, 50};  // √çndices v√°lidos: 0-4

// ‚ùå ERRADO - Acesso inv√°lido
printf("%d\n", vetor[5]);   // √çndice 5 n√£o existe!
vetor[-1] = 100;            // √çndice negativo!
vetor[10] = 200;            // Muito al√©m do limite!

// Consequ√™ncias:
// - L√™/escreve em mem√≥ria de outra vari√°vel
// - Pode causar segmentation fault (crash)
// - Comportamento indefinido (pior: parece funcionar √†s vezes!)

// ‚úÖ CORRETO - Sempre validar √≠ndices
int indice = 5;
if (indice >= 0 && indice < 5) {
    printf("%d\n", vetor[indice]);
} else {
    printf("Erro: √çndice %d fora dos limites [0-4]\n", indice);
}

// ‚úÖ Usar constantes e sizeof
#define TAM 5
int vetor[TAM];
for (int i = 0; i < TAM; i++) {  // Garante n√£o ultrapassar
    vetor[i] = i * 10;
}
```

### 3. Gerenciamento de Mem√≥ria Din√¢mica

```c
// ‚ùå Erro 1: N√£o verificar se malloc falhou
int *vetor = malloc(1000000000 * sizeof(int));  // Muita mem√≥ria!
vetor[0] = 10;  // CRASH! vetor √© NULL

// ‚úÖ SEMPRE verificar retorno do malloc
int *vetor = malloc(n * sizeof(int));
if (vetor == NULL) {
    fprintf(stderr, "Erro: N√£o foi poss√≠vel alocar mem√≥ria!\n");
    return 1;  // Ou outro tratamento apropriado
}
// Agora pode usar com seguran√ßa
free(vetor);  // E liberar!

// ‚ùå Erro 2: Memory leak (vazamento de mem√≥ria)
void funcao_com_leak() {
    int *dados = malloc(100 * sizeof(int));
    // ... usar dados ...
    return;  // ‚ùå Esqueceu de fazer free(dados)!
}
// A cada chamada, 400 bytes s√£o perdidos!

// ‚úÖ SEMPRE liberar o que alocou
void funcao_correta() {
    int *dados = malloc(100 * sizeof(int));
    if (dados == NULL) return;
    // ... usar dados ...
    free(dados);  // ‚úÖ Liberou a mem√≥ria
}

// ‚ùå Erro 3: Double free
int *ptr = malloc(10 * sizeof(int));
free(ptr);
free(ptr);  // ‚ùå ERRO! Liberou a mesma mem√≥ria duas vezes

// ‚úÖ Anular ponteiro ap√≥s free
int *ptr = malloc(10 * sizeof(int));
free(ptr);
ptr = NULL;  // ‚úÖ Evita uso acidental

// ‚ùå Erro 4: Use after free
int *ptr = malloc(10 * sizeof(int));
free(ptr);
ptr[0] = 10;  // ‚ùå ERRO! Usando mem√≥ria j√° liberada

// ‚úÖ N√£o usar ap√≥s liberar
int *ptr = malloc(10 * sizeof(int));
// ... usar ptr ...
free(ptr);
ptr = NULL;
// Agora qualquer tentativa de usar ptr gerar√° erro √≥bvio
```

### 4. Matrizes: Cuidados Especiais

```c
// ‚ùå Erro: Confundir ordem dos √≠ndices
int matriz[3][4];  // 3 linhas, 4 colunas
matriz[4][2] = 10;  // ‚ùå ERRO! Linha 4 n√£o existe (vai at√© 2)

// ‚úÖ Lembrar: matriz[linha][coluna]
#define LINHAS 3
#define COLUNAS 4
int matriz[LINHAS][COLUNAS];

for (int i = 0; i < LINHAS; i++) {
    for (int j = 0; j < COLUNAS; j++) {
        matriz[i][j] = i * COLUNAS + j;  // ‚úÖ Sempre dentro dos limites
    }
}

// ‚ùå Erro: Liberar matriz din√¢mica incorretamente
int **mat = alocar_matriz(linhas, colunas);
free(mat);  // ‚ùå ERRO! N√£o liberou as linhas individuais

// ‚úÖ Liberar na ordem correta
int **mat = alocar_matriz(linhas, colunas);
// ... usar matriz ...
for (int i = 0; i < linhas; i++) {
    free(mat[i]);  // Libera cada linha primeiro
}
free(mat);  // Depois libera o array de ponteiros
```

### 5. Problemas com String Terminators

```c
// ‚ùå Erro: Esquecer o terminador '\0'
char str[5];
str[0] = 'O'; str[1] = 'l'; str[2] = 'a'; str[3] = '!';
// str[4] deveria ser '\0' mas n√£o foi definido!
printf("%s\n", str);  // Imprime lixo depois de "Ola!"

// ‚úÖ Sempre adicionar '\0'
char str[5];
str[0] = 'O'; str[1] = 'l'; str[2] = 'a'; str[3] = '!'; str[4] = '\0';
printf("%s\n", str);  // ‚úÖ Imprime "Ola!" corretamente

// ‚ùå Erro: Contar tamanho sem '\0'
char nome[10];
// Precisa de 11 caracteres: "Jo√£o Silva" + '\0'
strcpy(nome, "Jo√£o Silva");  // ‚ùå Overflow!

// ‚úÖ Lembrar que '\0' ocupa espa√ßo
char nome[11];  // 10 caracteres + '\0'
strcpy(nome, "Jo√£o Silva");  // ‚úÖ Cabe perfeitamente
```

### 6. Performance: Cache Locality

```c
// ‚ùå LENTO - Acessa matriz por colunas
int soma = 0;
for (int j = 0; j < COLUNAS; j++) {
    for (int i = 0; i < LINHAS; i++) {
        soma += matriz[i][j];  // Cache miss frequente!
    }
}

// ‚úÖ R√ÅPIDO - Acessa por linhas (ordem na mem√≥ria)
int soma = 0;
for (int i = 0; i < LINHAS; i++) {
    for (int j = 0; j < COLUNAS; j++) {
        soma += matriz[i][j];  // Cache hit frequente!
    }
}

// Diferen√ßa: Pode ser 3-5√ó mais r√°pido em matrizes grandes!
```

### 7. Overflow Aritm√©tico

```c
// ‚ùå Perigo: Overflow em c√°lculo de √≠ndice
int i = 1000000000;
int j = 1000000000;
int indice = i + j;  // ‚ùå Overflow! Pode dar valor negativo

// ‚úÖ Verificar antes de calcular
if (i > INT_MAX - j) {
    printf("Erro: Soma causaria overflow!\n");
} else {
    int indice = i + j;
}

// ‚ùå Perigo: Overflow em malloc
size_t n = 1000000000;
int *vetor = malloc(n * n * sizeof(int));  // n¬≤ pode overflow!

// ‚úÖ Verificar antes de multiplicar
if (n > SIZE_MAX / n / sizeof(int)) {
    printf("Erro: Tamanho muito grande!\n");
    return NULL;
}
int *vetor = malloc(n * n * sizeof(int));
```

### üìã Checklist de Seguran√ßa

Antes de usar vetores/matrizes, sempre verifique:

- [ ] ‚úÖ Validei todos os √≠ndices antes de acessar?
- [ ] ‚úÖ Strings t√™m espa√ßo para o '\0'?
- [ ] ‚úÖ Verifico se malloc retornou NULL?
- [ ] ‚úÖ Para cada malloc, h√° um free correspondente?
- [ ] ‚úÖ N√£o uso ponteiros ap√≥s free?
- [ ] ‚úÖ Percorro matrizes na ordem correta (por linhas)?
- [ ] ‚úÖ Usei strncpy/snprintf ao inv√©s de strcpy/sprintf?
- [ ] ‚úÖ C√°lculos de tamanho n√£o causam overflow?

**Regra de Ouro:** Quando em d√∫vida, valide! √â melhor um `if` extra do que um bug silencioso.

---

## üéØ Pr√≥ximos Passos

Ap√≥s dominar vetores e matrizes:
1. **Listas Ligadas** - Estruturas din√¢micas
2. **Pilhas e Filas** - Implementadas com vetores
3. **√Årvores** - Estruturas hier√°rquicas
4. **Grafos** - Representa√ß√£o com matrizes de adjac√™ncia

---

## üìö Arquivos de Exemplo

| Arquivo | Descri√ß√£o |
|---------|-----------|
| `vetor/exemplo/exemploSimples.c` | Opera√ß√µes b√°sicas com vetores |
| `vetor/exemplo/exemploStringVetores.c` | Manipula√ß√£o de strings com vetores |
| `matriz/exemploMatrizSimples.c` | Opera√ß√µes b√°sicas com matrizes |
| `aplicacoes-praticas.c` | Aplica√ß√µes reais |
| `questoes-academicas.md` | Exerc√≠cios e teoria |

**Estude, pratique e domine as estruturas fundamentais da programa√ß√£o em C!** üöÄ