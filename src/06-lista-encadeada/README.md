# Listas Encadeadas em C

## üìã Vis√£o Geral

As listas encadeadas s√£o estruturas de dados din√¢micas fundamentais que permitem armazenar elementos de forma n√£o cont√≠gua na mem√≥ria. Este m√≥dulo apresenta implementa√ß√µes completas de diferentes tipos de listas encadeadas em C, explorando suas caracter√≠sticas, vantagens e aplica√ß√µes pr√°ticas.

## üîó Conceitos Fundamentais

### O que √© uma Lista Encadeada?

Uma lista encadeada √© uma estrutura de dados linear onde os elementos (n√≥s) s√£o armazenados em posi√ß√µes arbitr√°rias da mem√≥ria e conectados atrav√©s de ponteiros. Cada n√≥ cont√©m dados e uma refer√™ncia (ponteiro) para o pr√≥ximo n√≥ da sequ√™ncia.

#### Caracter√≠sticas Principais
- **Tamanho Din√¢mico**: Cresce e diminui durante a execu√ß√£o
- **Aloca√ß√£o N√£o Cont√≠gua**: N√≥s podem estar em qualquer lugar da mem√≥ria
- **Acesso Sequencial**: Necess√°rio percorrer desde o in√≠cio
- **Efici√™ncia em Inser√ß√µes/Remo√ß√µes**: O(1) em posi√ß√µes conhecidas

## üóÇÔ∏è Tipos de Listas Implementadas

### 1. Lista Simplesmente Encadeada
- **Arquivo**: `listaSimples.c`
- **Caracter√≠sticas**: Cada n√≥ aponta apenas para o pr√≥ximo
- **Navega√ß√£o**: Unidirecional (apenas para frente)

### 2. Lista Duplamente Encadeada
- **Arquivo**: `listaDupla.c`
- **Caracter√≠sticas**: Cada n√≥ tem ponteiros para anterior e pr√≥ximo
- **Navega√ß√£o**: Bidirecional (frente e tr√°s)

### 3. Exemplos Incrementais
- **`exemplo0.c`**: Conceitos b√°sicos e primeiro n√≥
- **`exemplo1.c`**: Inser√ß√£o no in√≠cio
- **`exemplo2.c`**: Inser√ß√£o no final
- **`exemplo3.c`**: Remo√ß√£o de elementos
- **`exemplo4.c`**: Busca e navega√ß√£o
- **`exemplo.c`**: Implementa√ß√£o completa

## üèóÔ∏è Estruturas de Dados

### Lista Simplesmente Encadeada
```c
typedef struct Node {
    int data;           // Dados do n√≥
    struct Node* next;  // Ponteiro para o pr√≥ximo n√≥
} Node;

typedef struct {
    Node* head;         // Ponteiro para o primeiro n√≥
    int size;          // Tamanho atual da lista
} LinkedList;
```

### Lista Duplamente Encadeada
```c
typedef struct DNode {
    int data;              // Dados do n√≥
    struct DNode* next;    // Ponteiro para o pr√≥ximo n√≥
    struct DNode* prev;    // Ponteiro para o n√≥ anterior
} DNode;

typedef struct {
    DNode* head;           // Ponteiro para o primeiro n√≥
    DNode* tail;           // Ponteiro para o √∫ltimo n√≥
    int size;             // Tamanho atual da lista
} DoublyLinkedList;
```

## ‚öôÔ∏è Opera√ß√µes Fundamentais

### Lista Simplesmente Encadeada

#### Inser√ß√£o
```c
// Inserir no in√≠cio - O(1)
void insertAtBeginning(LinkedList* list, int data);

// Inserir no final - O(n)
void insertAtEnd(LinkedList* list, int data);

// Inserir em posi√ß√£o espec√≠fica - O(n)
void insertAtPosition(LinkedList* list, int data, int position);
```

#### Remo√ß√£o
```c
// Remover do in√≠cio - O(1)
void removeFromBeginning(LinkedList* list);

// Remover do final - O(n)
void removeFromEnd(LinkedList* list);

// Remover por valor - O(n)
void removeByValue(LinkedList* list, int value);
```

#### Busca e Acesso
```c
// Buscar elemento - O(n)
Node* search(LinkedList* list, int value);

// Acessar por √≠ndice - O(n)
int getElement(LinkedList* list, int index);

// Exibir lista - O(n)
void displayList(LinkedList* list);
```

### Lista Duplamente Encadeada

#### Vantagens Adicionais
```c
// Inserir no final - O(1) (com ponteiro tail)
void insertAtEnd(DoublyLinkedList* list, int data);

// Remover do final - O(1) (com ponteiro tail)
void removeFromEnd(DoublyLinkedList* list);

// Navegar em ambas as dire√ß√µes
void displayForward(DoublyLinkedList* list);
void displayBackward(DoublyLinkedList* list);
```

## üìä An√°lise de Complexidade

| Opera√ß√£o | Lista Simples | Lista Dupla | Array Din√¢mico |
|----------|---------------|-------------|----------------|
| Inser√ß√£o in√≠cio | O(1) | O(1) | O(n) |
| Inser√ß√£o final | O(n) | O(1)* | O(1)** |
| Remo√ß√£o in√≠cio | O(1) | O(1) | O(n) |
| Remo√ß√£o final | O(n) | O(1)* | O(1) |
| Busca | O(n) | O(n) | O(n) |
| Acesso aleat√≥rio | O(n) | O(n) | O(1) |

*Com ponteiro tail  
**Amortizado

## üîß Vantagens e Desvantagens

### ‚úÖ Vantagens das Listas Encadeadas
- **Tamanho Din√¢mico**: N√£o h√° limite pr√©-definido
- **Inser√ß√£o/Remo√ß√£o Eficiente**: O(1) em posi√ß√µes conhecidas
- **Flexibilidade**: F√°cil reorganiza√ß√£o de elementos
- **Uso de Mem√≥ria**: Aloca apenas o necess√°rio

### ‚ùå Desvantagens das Listas Encadeadas
- **Overhead de Mem√≥ria**: Ponteiros extras por n√≥
- **Acesso Sequencial**: N√£o h√° acesso direto por √≠ndice
- **Cache Performance**: Elementos n√£o s√£o cont√≠guos
- **Complexidade**: Mais dif√≠cil de implementar que arrays

## üöÄ Aplica√ß√µes Pr√°ticas

### 1. Sistemas Operacionais
- **Lista de Processos**: Gerenciamento din√¢mico de processos
- **Gerenciamento de Mem√≥ria**: Blocos livres e ocupados
- **Escalonamento**: Filas de processos prontos

### 2. Estruturas de Dados Avan√ßadas
- **Implementa√ß√£o de Pilhas**: Stack baseada em lista
- **Implementa√ß√£o de Filas**: Queue com inser√ß√£o/remo√ß√£o eficiente
- **Grafos**: Lista de adjac√™ncias

### 3. Aplica√ß√µes Comerciais
- **Playlist de M√∫sica**: Navega√ß√£o entre m√∫sicas
- **Hist√≥rico de Navega√ß√£o**: Lista de p√°ginas visitadas
- **Carrinho de Compras**: Itens dinamicamente adicionados/removidos

### 4. Algoritmos
- **Merge Sort**: Divis√£o e conquista em listas
- **Detec√ß√£o de Ciclos**: Algoritmo de Floyd (tortoise and hare)
- **Revers√£o**: Invers√£o de sequ√™ncias

## üõ†Ô∏è Como Compilar e Executar

### Compila√ß√£o B√°sica
```bash
# Lista simples
gcc -o lista_simples listaSimples.c
./lista_simples

# Lista dupla
gcc -o lista_dupla listaDupla.c
./lista_dupla
```

### Compila√ß√£o com Debug
```bash
gcc -g -Wall -Wextra -o debug_lista listaSimples.c
gdb ./debug_lista
```

### Compila√ß√£o dos Exemplos
```bash
# Compilar todos os exemplos
for i in {0..4}; do
    gcc -o exemplo$i exemplo$i.c
    ./exemplo$i
done
```

## üéØ Exemplos de Implementa√ß√£o

### Criar e Inicializar Lista
```c
LinkedList* createList() {
    LinkedList* list = (LinkedList*)malloc(sizeof(LinkedList));
    list->head = NULL;
    list->size = 0;
    return list;
}
```

### Inser√ß√£o no In√≠cio
```c
void insertAtBeginning(LinkedList* list, int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = list->head;
    list->head = newNode;
    list->size++;
}
```

### Busca com Retorno de Posi√ß√£o
```c
int findPosition(LinkedList* list, int value) {
    Node* current = list->head;
    int position = 0;
    
    while (current != NULL) {
        if (current->data == value) {
            return position;
        }
        current = current->next;
        position++;
    }
    
    return -1; // N√£o encontrado
}
```

### Revers√£o de Lista
```c
void reverseList(LinkedList* list) {
    Node* prev = NULL;
    Node* current = list->head;
    Node* next = NULL;
    
    while (current != NULL) {
        next = current->next;    // Armazenar pr√≥ximo
        current->next = prev;    // Reverter o link
        prev = current;          // Mover prev
        current = next;          // Mover current
    }
    
    list->head = prev;          // Atualizar head
}
```

## üß† Padr√µes e T√©cnicas Avan√ßadas

### 1. T√©cnica dos Dois Ponteiros
```c
// Encontrar o meio da lista
Node* findMiddle(LinkedList* list) {
    Node* slow = list->head;
    Node* fast = list->head;
    
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
    }
    
    return slow;
}
```

### 2. Detec√ß√£o de Ciclos (Floyd's Algorithm)
```c
bool hasCycle(LinkedList* list) {
    Node* slow = list->head;
    Node* fast = list->head;
    
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
        
        if (slow == fast) {
            return true; // Ciclo detectado
        }
    }
    
    return false; // Sem ciclo
}
```

### 3. Merge de Listas Ordenadas
```c
LinkedList* mergeSortedLists(LinkedList* list1, LinkedList* list2) {
    LinkedList* merged = createList();
    Node* current1 = list1->head;
    Node* current2 = list2->head;
    
    while (current1 != NULL && current2 != NULL) {
        if (current1->data <= current2->data) {
            insertAtEnd(merged, current1->data);
            current1 = current1->next;
        } else {
            insertAtEnd(merged, current2->data);
            current2 = current2->next;
        }
    }
    
    // Adicionar elementos restantes
    while (current1 != NULL) {
        insertAtEnd(merged, current1->data);
        current1 = current1->next;
    }
    
    while (current2 != NULL) {
        insertAtEnd(merged, current2->data);
        current2 = current2->next;
    }
    
    return merged;
}
```

## ü§î Quest√µes para Reflex√£o

1. **An√°lise**: Por que listas encadeadas s√£o mais eficientes para inser√ß√µes/remo√ß√µes frequentes em compara√ß√£o com arrays?

2. **Implementa√ß√£o**: Como voc√™ implementaria uma fun√ß√£o para encontrar o k-√©simo elemento do final da lista em uma √∫nica passada?

3. **Mem√≥ria**: Calcule o overhead de mem√≥ria de uma lista encadeada versus um array para armazenar 1000 inteiros.

4. **Algoritmos**: Explique como o algoritmo de Floyd para detec√ß√£o de ciclos funciona matematicamente.

5. **Design**: Quando voc√™ escolheria uma lista duplamente encadeada em vez de uma lista simplesmente encadeada?

## üìã Exerc√≠cios Pr√°ticos

### N√≠vel B√°sico
1. Implemente uma fun√ß√£o que conte o n√∫mero de n√≥s na lista
2. Crie uma fun√ß√£o que encontre o maior elemento da lista
3. Desenvolva uma fun√ß√£o que remova todos os elementos duplicados

### N√≠vel Intermedi√°rio
4. Implemente uma fun√ß√£o que rotacione a lista k posi√ß√µes para a direita
5. Crie uma fun√ß√£o que intercale duas listas ordenadas
6. Desenvolva uma fun√ß√£o que agrupe n√≥s com valores pares e √≠mpares

### N√≠vel Avan√ßado
7. Implemente o algoritmo merge sort para listas encadeadas
8. Crie uma fun√ß√£o que detecte e remova ciclos em uma lista
9. Desenvolva uma estrutura de lista encadeada thread-safe

### Desafios
10. Implemente uma lista encadeada que mantenha refer√™ncias para elementos frequentemente acessados
11. Crie uma lista encadeada com compress√£o autom√°tica de elementos duplicados consecutivos
12. Desenvolva uma lista encadeada com snapshots (versioning)

## üîç Debugging e Testes

### Problemas Comuns
- **Memory Leaks**: N√£o liberar n√≥s removidos
- **Segmentation Fault**: Acessar ponteiros nulos
- **Ponteiros Perdidos**: Perder refer√™ncia para n√≥s
- **Ciclos Infinitos**: Criar refer√™ncias circulares

### T√©cnicas de Debug
```c
// Fun√ß√£o para verificar integridade da lista
bool verifyListIntegrity(LinkedList* list) {
    if (list->size == 0 && list->head != NULL) return false;
    if (list->size > 0 && list->head == NULL) return false;
    
    int count = 0;
    Node* current = list->head;
    while (current != NULL) {
        count++;
        current = current->next;
    }
    
    return count == list->size;
}
```

### Ferramentas √öteis
```bash
# Verificar vazamentos de mem√≥ria
valgrind --leak-check=full --track-origins=yes ./programa

# Debug step-by-step
gdb ./programa
(gdb) break insertAtBeginning
(gdb) run
(gdb) print *list
(gdb) step
```

## üìö Refer√™ncias e Leituras Complementares

- **Livros**:
  - Cormen, T. H. et al. *Introduction to Algorithms*. MIT Press.
  - Sedgewick, R. *Algorithms in C*. Addison-Wesley.
  - Tenenbaum, A. M. *Data Structures Using C*. Prentice Hall.

- **Artigos**:
  - Floyd, R. W. (1967). "Nondeterministic Algorithms". *Journal of the ACM*.
  - Knuth, D. E. (1973). "Sorting and Searching". *The Art of Computer Programming*.

- **Recursos Online**:
  - GeeksforGeeks: Data Structures
  - CS50: Harvard's Computer Science Course
  - MIT OpenCourseWare: Introduction to Algorithms